<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenRadical: ts2/opm53/tools/sce/ee/gcc/include/g++-v3/bits/stl_algo.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenRadical
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_9210f49a5fe20be6b5321aca57fbe4d2.html">ts2</a></li><li class="navelem"><a class="el" href="dir_cc2422225e961cad96549d976097f45a.html">opm53</a></li><li class="navelem"><a class="el" href="dir_28a9c6f745bbbbc1d1cdf1b1ee6a864d.html">tools</a></li><li class="navelem"><a class="el" href="dir_f8283f63c9fcde7cdc36f59b207464ec.html">sce</a></li><li class="navelem"><a class="el" href="dir_93f94442862b7e706dd69b6e52deadc1.html">ee</a></li><li class="navelem"><a class="el" href="dir_3edb1a85ada57b6bda4ac783660f1292.html">gcc</a></li><li class="navelem"><a class="el" href="dir_48f2f1cbcc0d98b9155dace9734121ed.html">include</a></li><li class="navelem"><a class="el" href="dir_cae182e9c81325f5bb08463d427bd9c2.html">g++-v3</a></li><li class="navelem"><a class="el" href="dir_0a3552291b585753d50f2b48b0c444d4.html">bits</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">stl_algo.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="stl__heap_8h_source.html">bits/stl_heap.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="stl__tempbuf_8h_source.html">bits/stl_tempbuf.h</a>&gt;</code><br />
</div>
<p><a href="stl__algo_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af72ebc2c525774452cb690f3d9c55318" id="r_af72ebc2c525774452cb690f3d9c55318"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>_M_threshold</b> = 16
 }</td></tr>
<tr class="separator:af72ebc2c525774452cb690f3d9c55318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9df0ac3ae00ed33b19ffb199c972a4" id="r_a4e9df0ac3ae00ed33b19ffb199c972a4"><td class="memItemLeft" align="right" valign="top"><a id="a4e9df0ac3ae00ed33b19ffb199c972a4" name="a4e9df0ac3ae00ed33b19ffb199c972a4"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>_M_chunk_size</b> = 7
 }</td></tr>
<tr class="separator:a4e9df0ac3ae00ed33b19ffb199c972a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acfafe0f6028944b3d3e046b184ded3d3" id="r_acfafe0f6028944b3d3e046b184ded3d3"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:acfafe0f6028944b3d3e046b184ded3d3"><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acfafe0f6028944b3d3e046b184ded3d3">std::__median</a> (const _Tp &amp;__a, const _Tp &amp;__b, const _Tp &amp;__c)</td></tr>
<tr class="memdesc:acfafe0f6028944b3d3e046b184ded3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the median of three values.  <br /></td></tr>
<tr class="separator:acfafe0f6028944b3d3e046b184ded3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab268ba304c7e2d8f07ce30437908c9b0" id="r_ab268ba304c7e2d8f07ce30437908c9b0"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:ab268ba304c7e2d8f07ce30437908c9b0"><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab268ba304c7e2d8f07ce30437908c9b0">std::__median</a> (const _Tp &amp;__a, const _Tp &amp;__b, const _Tp &amp;__c, _Compare __comp)</td></tr>
<tr class="memdesc:ab268ba304c7e2d8f07ce30437908c9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the median of three values using a predicate for comparison.  <br /></td></tr>
<tr class="separator:ab268ba304c7e2d8f07ce30437908c9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542b04562bb781d328f6f1469d24f330" id="r_a542b04562bb781d328f6f1469d24f330"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _Function &gt; </td></tr>
<tr class="memitem:a542b04562bb781d328f6f1469d24f330"><td class="memTemplItemLeft" align="right" valign="top">_Function&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a542b04562bb781d328f6f1469d24f330">std::for_each</a> (_InputIter __first, _InputIter __last, _Function __f)</td></tr>
<tr class="memdesc:a542b04562bb781d328f6f1469d24f330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to every element of a sequence.  <br /></td></tr>
<tr class="separator:a542b04562bb781d328f6f1469d24f330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8edd66dd0a134f061c106e256e55e47" id="r_ae8edd66dd0a134f061c106e256e55e47"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _Tp &gt; </td></tr>
<tr class="memitem:ae8edd66dd0a134f061c106e256e55e47"><td class="memTemplItemLeft" align="right" valign="top">_InputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8edd66dd0a134f061c106e256e55e47">std::find</a> (_InputIter __first, _InputIter __last, const _Tp &amp;__val, <a class="el" href="structstd_1_1input__iterator__tag.html">input_iterator_tag</a>)</td></tr>
<tr class="separator:ae8edd66dd0a134f061c106e256e55e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8d9cc1e16f0a3abc5fbd6652e78680" id="r_a2f8d9cc1e16f0a3abc5fbd6652e78680"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _Predicate &gt; </td></tr>
<tr class="memitem:a2f8d9cc1e16f0a3abc5fbd6652e78680"><td class="memTemplItemLeft" align="right" valign="top">_InputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2f8d9cc1e16f0a3abc5fbd6652e78680">std::find_if</a> (_InputIter __first, _InputIter __last, _Predicate __pred, <a class="el" href="structstd_1_1input__iterator__tag.html">input_iterator_tag</a>)</td></tr>
<tr class="separator:a2f8d9cc1e16f0a3abc5fbd6652e78680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24761c8bdc546aac768fbda09b80208" id="r_ad24761c8bdc546aac768fbda09b80208"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Tp &gt; </td></tr>
<tr class="memitem:ad24761c8bdc546aac768fbda09b80208"><td class="memTemplItemLeft" align="right" valign="top">_RandomAccessIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad24761c8bdc546aac768fbda09b80208">std::find</a> (_RandomAccessIter __first, _RandomAccessIter __last, const _Tp &amp;__val, <a class="el" href="structstd_1_1random__access__iterator__tag.html">random_access_iterator_tag</a>)</td></tr>
<tr class="separator:ad24761c8bdc546aac768fbda09b80208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ab3570432560da0f4328b6e1493b87" id="r_a51ab3570432560da0f4328b6e1493b87"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Predicate &gt; </td></tr>
<tr class="memitem:a51ab3570432560da0f4328b6e1493b87"><td class="memTemplItemLeft" align="right" valign="top">_RandomAccessIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a51ab3570432560da0f4328b6e1493b87">std::find_if</a> (_RandomAccessIter __first, _RandomAccessIter __last, _Predicate __pred, <a class="el" href="structstd_1_1random__access__iterator__tag.html">random_access_iterator_tag</a>)</td></tr>
<tr class="separator:a51ab3570432560da0f4328b6e1493b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec58dba3311501c8d67b08ed021befd6" id="r_aec58dba3311501c8d67b08ed021befd6"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _Tp &gt; </td></tr>
<tr class="memitem:aec58dba3311501c8d67b08ed021befd6"><td class="memTemplItemLeft" align="right" valign="top">_InputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec58dba3311501c8d67b08ed021befd6">std::find</a> (_InputIter __first, _InputIter __last, const _Tp &amp;__val)</td></tr>
<tr class="memdesc:aec58dba3311501c8d67b08ed021befd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a value in a sequence.  <br /></td></tr>
<tr class="separator:aec58dba3311501c8d67b08ed021befd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1210ba14a5ed7e9cbdef76d974fb9cbb" id="r_a1210ba14a5ed7e9cbdef76d974fb9cbb"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _Predicate &gt; </td></tr>
<tr class="memitem:a1210ba14a5ed7e9cbdef76d974fb9cbb"><td class="memTemplItemLeft" align="right" valign="top">_InputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1210ba14a5ed7e9cbdef76d974fb9cbb">std::find_if</a> (_InputIter __first, _InputIter __last, _Predicate __pred)</td></tr>
<tr class="memdesc:a1210ba14a5ed7e9cbdef76d974fb9cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first element in a sequence for which a predicate is true.  <br /></td></tr>
<tr class="separator:a1210ba14a5ed7e9cbdef76d974fb9cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12db853751ef756b2bdb6c059677e522" id="r_a12db853751ef756b2bdb6c059677e522"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter &gt; </td></tr>
<tr class="memitem:a12db853751ef756b2bdb6c059677e522"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12db853751ef756b2bdb6c059677e522">std::adjacent_find</a> (_ForwardIter __first, _ForwardIter __last)</td></tr>
<tr class="memdesc:a12db853751ef756b2bdb6c059677e522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find two adjacent values in a sequence that are equal.  <br /></td></tr>
<tr class="separator:a12db853751ef756b2bdb6c059677e522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7221da3df1fbdc5460d1c11dc294ca7c" id="r_a7221da3df1fbdc5460d1c11dc294ca7c"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:a7221da3df1fbdc5460d1c11dc294ca7c"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7221da3df1fbdc5460d1c11dc294ca7c">std::adjacent_find</a> (_ForwardIter __first, _ForwardIter __last, _BinaryPredicate __binary_pred)</td></tr>
<tr class="memdesc:a7221da3df1fbdc5460d1c11dc294ca7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find two adjacent values in a sequence using a predicate.  <br /></td></tr>
<tr class="separator:a7221da3df1fbdc5460d1c11dc294ca7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd50872b0adb3f2567455aee86b4ffb" id="r_a9cd50872b0adb3f2567455aee86b4ffb"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _Tp &gt; </td></tr>
<tr class="memitem:a9cd50872b0adb3f2567455aee86b4ffb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1iterator__traits.html">iterator_traits</a>&lt; _InputIter &gt;::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9cd50872b0adb3f2567455aee86b4ffb">std::count</a> (_InputIter __first, _InputIter __last, const _Tp &amp;__value)</td></tr>
<tr class="memdesc:a9cd50872b0adb3f2567455aee86b4ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of copies of a value in a sequence.  <br /></td></tr>
<tr class="separator:a9cd50872b0adb3f2567455aee86b4ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f00d011c331e2aae5c2a04b4e19c5d" id="r_af6f00d011c331e2aae5c2a04b4e19c5d"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _Predicate &gt; </td></tr>
<tr class="memitem:af6f00d011c331e2aae5c2a04b4e19c5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1iterator__traits.html">iterator_traits</a>&lt; _InputIter &gt;::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af6f00d011c331e2aae5c2a04b4e19c5d">std::count_if</a> (_InputIter __first, _InputIter __last, _Predicate __pred)</td></tr>
<tr class="memdesc:af6f00d011c331e2aae5c2a04b4e19c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the elements of a sequence for which a predicate is true.  <br /></td></tr>
<tr class="separator:af6f00d011c331e2aae5c2a04b4e19c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188534039e6c73cdc85cc67fa885d4d8" id="r_a188534039e6c73cdc85cc67fa885d4d8"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter1 , typename _ForwardIter2 &gt; </td></tr>
<tr class="memitem:a188534039e6c73cdc85cc67fa885d4d8"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a188534039e6c73cdc85cc67fa885d4d8">std::search</a> (_ForwardIter1 __first1, _ForwardIter1 __last1, _ForwardIter2 __first2, _ForwardIter2 __last2)</td></tr>
<tr class="memdesc:a188534039e6c73cdc85cc67fa885d4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a sequence for a matching sub-sequence.  <br /></td></tr>
<tr class="separator:a188534039e6c73cdc85cc67fa885d4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e1cf66ada7e64dcec0df53abdf0098" id="r_ae9e1cf66ada7e64dcec0df53abdf0098"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter1 , typename _ForwardIter2 , typename _BinaryPred &gt; </td></tr>
<tr class="memitem:ae9e1cf66ada7e64dcec0df53abdf0098"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae9e1cf66ada7e64dcec0df53abdf0098">std::search</a> (_ForwardIter1 __first1, _ForwardIter1 __last1, _ForwardIter2 __first2, _ForwardIter2 __last2, _BinaryPred __predicate)</td></tr>
<tr class="memdesc:ae9e1cf66ada7e64dcec0df53abdf0098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a sequence for a matching sub-sequence using a predicate.  <br /></td></tr>
<tr class="separator:ae9e1cf66ada7e64dcec0df53abdf0098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d668a295c3a05426cef757e0d674b9" id="r_ab9d668a295c3a05426cef757e0d674b9"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Integer , typename _Tp &gt; </td></tr>
<tr class="memitem:ab9d668a295c3a05426cef757e0d674b9"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab9d668a295c3a05426cef757e0d674b9">std::search_n</a> (_ForwardIter __first, _ForwardIter __last, _Integer __count, const _Tp &amp;__val)</td></tr>
<tr class="memdesc:ab9d668a295c3a05426cef757e0d674b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a sequence for a number of consecutive values.  <br /></td></tr>
<tr class="separator:ab9d668a295c3a05426cef757e0d674b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4041a96488aa77dd01a3702c82478248" id="r_a4041a96488aa77dd01a3702c82478248"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Integer , typename _Tp , typename _BinaryPred &gt; </td></tr>
<tr class="memitem:a4041a96488aa77dd01a3702c82478248"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4041a96488aa77dd01a3702c82478248">std::search_n</a> (_ForwardIter __first, _ForwardIter __last, _Integer __count, const _Tp &amp;__val, _BinaryPred __binary_pred)</td></tr>
<tr class="memdesc:a4041a96488aa77dd01a3702c82478248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a sequence for a number of consecutive values using a predicate.  <br /></td></tr>
<tr class="separator:a4041a96488aa77dd01a3702c82478248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a484f4e4eb5fd5ca0b32b1e9c0c8e" id="r_a5a9a484f4e4eb5fd5ca0b32b1e9c0c8e"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter1 , typename _ForwardIter2 &gt; </td></tr>
<tr class="memitem:a5a9a484f4e4eb5fd5ca0b32b1e9c0c8e"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a9a484f4e4eb5fd5ca0b32b1e9c0c8e">std::swap_ranges</a> (_ForwardIter1 __first1, _ForwardIter1 __last1, _ForwardIter2 __first2)</td></tr>
<tr class="memdesc:a5a9a484f4e4eb5fd5ca0b32b1e9c0c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the elements of two sequences.  <br /></td></tr>
<tr class="separator:a5a9a484f4e4eb5fd5ca0b32b1e9c0c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4692cff18c740e185497f8c8250e59c5" id="r_a4692cff18c740e185497f8c8250e59c5"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _OutputIter , typename _UnaryOperation &gt; </td></tr>
<tr class="memitem:a4692cff18c740e185497f8c8250e59c5"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4692cff18c740e185497f8c8250e59c5">std::transform</a> (_InputIter __first, _InputIter __last, _OutputIter __result, _UnaryOperation __unary_op)</td></tr>
<tr class="memdesc:a4692cff18c740e185497f8c8250e59c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an operation on a sequence.  <br /></td></tr>
<tr class="separator:a4692cff18c740e185497f8c8250e59c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55206a338db443b81119946d0b58bbc3" id="r_a55206a338db443b81119946d0b58bbc3"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter1 , typename _InputIter2 , typename _OutputIter , typename _BinaryOperation &gt; </td></tr>
<tr class="memitem:a55206a338db443b81119946d0b58bbc3"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a55206a338db443b81119946d0b58bbc3">std::transform</a> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _OutputIter __result, _BinaryOperation __binary_op)</td></tr>
<tr class="memdesc:a55206a338db443b81119946d0b58bbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an operation on corresponding elements of two sequences.  <br /></td></tr>
<tr class="separator:a55206a338db443b81119946d0b58bbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5666f66f610eace0700f415d19d39ed" id="r_af5666f66f610eace0700f415d19d39ed"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Tp &gt; </td></tr>
<tr class="memitem:af5666f66f610eace0700f415d19d39ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5666f66f610eace0700f415d19d39ed">std::replace</a> (_ForwardIter __first, _ForwardIter __last, const _Tp &amp;__old_value, const _Tp &amp;__new_value)</td></tr>
<tr class="memdesc:af5666f66f610eace0700f415d19d39ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace each occurrence of one value in a sequence with another value.  <br /></td></tr>
<tr class="separator:af5666f66f610eace0700f415d19d39ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc12af221d25bb64e65d04703322e1a" id="r_acdc12af221d25bb64e65d04703322e1a"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Predicate , typename _Tp &gt; </td></tr>
<tr class="memitem:acdc12af221d25bb64e65d04703322e1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acdc12af221d25bb64e65d04703322e1a">std::replace_if</a> (_ForwardIter __first, _ForwardIter __last, _Predicate __pred, const _Tp &amp;__new_value)</td></tr>
<tr class="memdesc:acdc12af221d25bb64e65d04703322e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace each value in a sequence for which a predicate returns true with another value.  <br /></td></tr>
<tr class="separator:acdc12af221d25bb64e65d04703322e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b7eae0504409cbaac8679717115bdd" id="r_a09b7eae0504409cbaac8679717115bdd"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _OutputIter , typename _Tp &gt; </td></tr>
<tr class="memitem:a09b7eae0504409cbaac8679717115bdd"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09b7eae0504409cbaac8679717115bdd">std::replace_copy</a> (_InputIter __first, _InputIter __last, _OutputIter __result, const _Tp &amp;__old_value, const _Tp &amp;__new_value)</td></tr>
<tr class="memdesc:a09b7eae0504409cbaac8679717115bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sequence, replacing each element of one value with another value.  <br /></td></tr>
<tr class="separator:a09b7eae0504409cbaac8679717115bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b09d97c77f662fe49b9e9fb8363f18" id="r_ad9b09d97c77f662fe49b9e9fb8363f18"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _OutputIter , typename _Predicate , typename _Tp &gt; </td></tr>
<tr class="memitem:ad9b09d97c77f662fe49b9e9fb8363f18"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9b09d97c77f662fe49b9e9fb8363f18">std::replace_copy_if</a> (_InputIter __first, _InputIter __last, _OutputIter __result, _Predicate __pred, const _Tp &amp;__new_value)</td></tr>
<tr class="memdesc:ad9b09d97c77f662fe49b9e9fb8363f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sequence, replacing each value for which a predicate returns true with another value.  <br /></td></tr>
<tr class="separator:ad9b09d97c77f662fe49b9e9fb8363f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d34c40a64f3e7c240dfe9daa32c2593" id="r_a8d34c40a64f3e7c240dfe9daa32c2593"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Generator &gt; </td></tr>
<tr class="memitem:a8d34c40a64f3e7c240dfe9daa32c2593"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d34c40a64f3e7c240dfe9daa32c2593">std::generate</a> (_ForwardIter __first, _ForwardIter __last, _Generator __gen)</td></tr>
<tr class="memdesc:a8d34c40a64f3e7c240dfe9daa32c2593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the result of a function object to each value in a sequence.  <br /></td></tr>
<tr class="separator:a8d34c40a64f3e7c240dfe9daa32c2593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089737e512a7a280895691c17f03ec3b" id="r_a089737e512a7a280895691c17f03ec3b"><td class="memTemplParams" colspan="2">template&lt;typename _OutputIter , typename _Size , typename _Generator &gt; </td></tr>
<tr class="memitem:a089737e512a7a280895691c17f03ec3b"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a089737e512a7a280895691c17f03ec3b">std::generate_n</a> (_OutputIter __first, _Size __n, _Generator __gen)</td></tr>
<tr class="memdesc:a089737e512a7a280895691c17f03ec3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the result of a function object to each value in a sequence.  <br /></td></tr>
<tr class="separator:a089737e512a7a280895691c17f03ec3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f4f64570a6c897ab5e80bdd6f99aa6" id="r_a41f4f64570a6c897ab5e80bdd6f99aa6"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _OutputIter , typename _Tp &gt; </td></tr>
<tr class="memitem:a41f4f64570a6c897ab5e80bdd6f99aa6"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a41f4f64570a6c897ab5e80bdd6f99aa6">std::remove_copy</a> (_InputIter __first, _InputIter __last, _OutputIter __result, const _Tp &amp;__value)</td></tr>
<tr class="memdesc:a41f4f64570a6c897ab5e80bdd6f99aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sequence, removing elements of a given value.  <br /></td></tr>
<tr class="separator:a41f4f64570a6c897ab5e80bdd6f99aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdc43e3bac32bdebb3f1ad6274cc129" id="r_a4bdc43e3bac32bdebb3f1ad6274cc129"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _OutputIter , typename _Predicate &gt; </td></tr>
<tr class="memitem:a4bdc43e3bac32bdebb3f1ad6274cc129"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4bdc43e3bac32bdebb3f1ad6274cc129">std::remove_copy_if</a> (_InputIter __first, _InputIter __last, _OutputIter __result, _Predicate __pred)</td></tr>
<tr class="memdesc:a4bdc43e3bac32bdebb3f1ad6274cc129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sequence, removing elements for which a predicate is true.  <br /></td></tr>
<tr class="separator:a4bdc43e3bac32bdebb3f1ad6274cc129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d776a1cc211c394f7bf650240045bb1" id="r_a8d776a1cc211c394f7bf650240045bb1"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Tp &gt; </td></tr>
<tr class="memitem:a8d776a1cc211c394f7bf650240045bb1"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d776a1cc211c394f7bf650240045bb1">std::remove</a> (_ForwardIter __first, _ForwardIter __last, const _Tp &amp;__value)</td></tr>
<tr class="memdesc:a8d776a1cc211c394f7bf650240045bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements from a sequence.  <br /></td></tr>
<tr class="separator:a8d776a1cc211c394f7bf650240045bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad512bd34540bb7c634080af1b004f852" id="r_ad512bd34540bb7c634080af1b004f852"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Predicate &gt; </td></tr>
<tr class="memitem:ad512bd34540bb7c634080af1b004f852"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad512bd34540bb7c634080af1b004f852">std::remove_if</a> (_ForwardIter __first, _ForwardIter __last, _Predicate __pred)</td></tr>
<tr class="memdesc:ad512bd34540bb7c634080af1b004f852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements from a sequence using a predicate.  <br /></td></tr>
<tr class="separator:ad512bd34540bb7c634080af1b004f852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa07440e73b6aac197ae036f0d60014" id="r_a7aa07440e73b6aac197ae036f0d60014"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:a7aa07440e73b6aac197ae036f0d60014"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7aa07440e73b6aac197ae036f0d60014">std::__unique_copy</a> (_InputIter __first, _InputIter __last, _OutputIter __result, <a class="el" href="structstd_1_1output__iterator__tag.html">output_iterator_tag</a>)</td></tr>
<tr class="separator:a7aa07440e73b6aac197ae036f0d60014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373709bf00c6344ff9c4faeda775f0e7" id="r_a373709bf00c6344ff9c4faeda775f0e7"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _ForwardIter &gt; </td></tr>
<tr class="memitem:a373709bf00c6344ff9c4faeda775f0e7"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a373709bf00c6344ff9c4faeda775f0e7">std::__unique_copy</a> (_InputIter __first, _InputIter __last, _ForwardIter __result, <a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a>)</td></tr>
<tr class="separator:a373709bf00c6344ff9c4faeda775f0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39def218a9f4e3d769ef94c14f76346" id="r_ae39def218a9f4e3d769ef94c14f76346"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:ae39def218a9f4e3d769ef94c14f76346"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae39def218a9f4e3d769ef94c14f76346">std::unique_copy</a> (_InputIter __first, _InputIter __last, _OutputIter __result)</td></tr>
<tr class="memdesc:ae39def218a9f4e3d769ef94c14f76346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sequence, removing consecutive duplicate values.  <br /></td></tr>
<tr class="separator:ae39def218a9f4e3d769ef94c14f76346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68504549419625d2b27e25fb29cd6e4a" id="r_a68504549419625d2b27e25fb29cd6e4a"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _OutputIter , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:a68504549419625d2b27e25fb29cd6e4a"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a68504549419625d2b27e25fb29cd6e4a">std::__unique_copy</a> (_InputIter __first, _InputIter __last, _OutputIter __result, _BinaryPredicate __binary_pred, <a class="el" href="structstd_1_1output__iterator__tag.html">output_iterator_tag</a>)</td></tr>
<tr class="separator:a68504549419625d2b27e25fb29cd6e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c16e74048f162a1761c70819a5e2c3" id="r_a42c16e74048f162a1761c70819a5e2c3"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _ForwardIter , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:a42c16e74048f162a1761c70819a5e2c3"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a42c16e74048f162a1761c70819a5e2c3">std::__unique_copy</a> (_InputIter __first, _InputIter __last, _ForwardIter __result, _BinaryPredicate __binary_pred, <a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a>)</td></tr>
<tr class="separator:a42c16e74048f162a1761c70819a5e2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac8e7887baf1130e364901ed4f66cfb" id="r_adac8e7887baf1130e364901ed4f66cfb"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _OutputIter , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:adac8e7887baf1130e364901ed4f66cfb"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adac8e7887baf1130e364901ed4f66cfb">std::unique_copy</a> (_InputIter __first, _InputIter __last, _OutputIter __result, _BinaryPredicate __binary_pred)</td></tr>
<tr class="memdesc:adac8e7887baf1130e364901ed4f66cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sequence, removing consecutive values using a predicate.  <br /></td></tr>
<tr class="separator:adac8e7887baf1130e364901ed4f66cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83abb7a55b261ebfbcb77a2a7378241d" id="r_a83abb7a55b261ebfbcb77a2a7378241d"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter &gt; </td></tr>
<tr class="memitem:a83abb7a55b261ebfbcb77a2a7378241d"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a83abb7a55b261ebfbcb77a2a7378241d">std::unique</a> (_ForwardIter __first, _ForwardIter __last)</td></tr>
<tr class="memdesc:a83abb7a55b261ebfbcb77a2a7378241d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove consecutive duplicate values from a sequence.  <br /></td></tr>
<tr class="separator:a83abb7a55b261ebfbcb77a2a7378241d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c8d86db4df6c86a04b071c27cb1c7c" id="r_a38c8d86db4df6c86a04b071c27cb1c7c"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:a38c8d86db4df6c86a04b071c27cb1c7c"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38c8d86db4df6c86a04b071c27cb1c7c">std::unique</a> (_ForwardIter __first, _ForwardIter __last, _BinaryPredicate __binary_pred)</td></tr>
<tr class="memdesc:a38c8d86db4df6c86a04b071c27cb1c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove consecutive values from a sequence using a predicate.  <br /></td></tr>
<tr class="separator:a38c8d86db4df6c86a04b071c27cb1c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68957c635dfa16775ed66fae422ee6f1" id="r_a68957c635dfa16775ed66fae422ee6f1"><td class="memTemplParams" colspan="2">template&lt;typename _BidirectionalIter &gt; </td></tr>
<tr class="memitem:a68957c635dfa16775ed66fae422ee6f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a68957c635dfa16775ed66fae422ee6f1">std::__reverse</a> (_BidirectionalIter __first, _BidirectionalIter __last, <a class="el" href="structstd_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a>)</td></tr>
<tr class="separator:a68957c635dfa16775ed66fae422ee6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295a53399a8d207447498663b887f16d" id="r_a295a53399a8d207447498663b887f16d"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter &gt; </td></tr>
<tr class="memitem:a295a53399a8d207447498663b887f16d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a295a53399a8d207447498663b887f16d">std::__reverse</a> (_RandomAccessIter __first, _RandomAccessIter __last, <a class="el" href="structstd_1_1random__access__iterator__tag.html">random_access_iterator_tag</a>)</td></tr>
<tr class="separator:a295a53399a8d207447498663b887f16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08e1b92afaac8a1223bba8ccf172973" id="r_aa08e1b92afaac8a1223bba8ccf172973"><td class="memTemplParams" colspan="2">template&lt;typename _BidirectionalIter &gt; </td></tr>
<tr class="memitem:aa08e1b92afaac8a1223bba8ccf172973"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa08e1b92afaac8a1223bba8ccf172973">std::reverse</a> (_BidirectionalIter __first, _BidirectionalIter __last)</td></tr>
<tr class="memdesc:aa08e1b92afaac8a1223bba8ccf172973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a sequence.  <br /></td></tr>
<tr class="separator:aa08e1b92afaac8a1223bba8ccf172973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8c9651e5104c15a6e3f99c67035998" id="r_acd8c9651e5104c15a6e3f99c67035998"><td class="memTemplParams" colspan="2">template&lt;typename _BidirectionalIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:acd8c9651e5104c15a6e3f99c67035998"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd8c9651e5104c15a6e3f99c67035998">std::reverse_copy</a> (_BidirectionalIter __first, _BidirectionalIter __last, _OutputIter __result)</td></tr>
<tr class="memdesc:acd8c9651e5104c15a6e3f99c67035998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sequence, reversing its elements.  <br /></td></tr>
<tr class="separator:acd8c9651e5104c15a6e3f99c67035998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64690c88f80577f3052168f0322749e6" id="r_a64690c88f80577f3052168f0322749e6"><td class="memTemplParams" colspan="2">template&lt;typename _EuclideanRingElement &gt; </td></tr>
<tr class="memitem:a64690c88f80577f3052168f0322749e6"><td class="memTemplItemLeft" align="right" valign="top">_EuclideanRingElement&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a64690c88f80577f3052168f0322749e6">std::__gcd</a> (_EuclideanRingElement __m, _EuclideanRingElement __n)</td></tr>
<tr class="separator:a64690c88f80577f3052168f0322749e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2497f652533c32547f894bea70a07119" id="r_a2497f652533c32547f894bea70a07119"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter &gt; </td></tr>
<tr class="memitem:a2497f652533c32547f894bea70a07119"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2497f652533c32547f894bea70a07119">std::__rotate</a> (_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last, <a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a>)</td></tr>
<tr class="separator:a2497f652533c32547f894bea70a07119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f211d404ebb9c55a8c42bb8888b3e8" id="r_af9f211d404ebb9c55a8c42bb8888b3e8"><td class="memTemplParams" colspan="2">template&lt;typename _BidirectionalIter &gt; </td></tr>
<tr class="memitem:af9f211d404ebb9c55a8c42bb8888b3e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9f211d404ebb9c55a8c42bb8888b3e8">std::__rotate</a> (_BidirectionalIter __first, _BidirectionalIter __middle, _BidirectionalIter __last, <a class="el" href="structstd_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a>)</td></tr>
<tr class="separator:af9f211d404ebb9c55a8c42bb8888b3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7ec97a5581f70eb8e903b9537d8acd" id="r_a2f7ec97a5581f70eb8e903b9537d8acd"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter &gt; </td></tr>
<tr class="memitem:a2f7ec97a5581f70eb8e903b9537d8acd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2f7ec97a5581f70eb8e903b9537d8acd">std::__rotate</a> (_RandomAccessIter __first, _RandomAccessIter __middle, _RandomAccessIter __last, <a class="el" href="structstd_1_1random__access__iterator__tag.html">random_access_iterator_tag</a>)</td></tr>
<tr class="separator:a2f7ec97a5581f70eb8e903b9537d8acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee50533ace388403bdc966d2326dfaa" id="r_adee50533ace388403bdc966d2326dfaa"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter &gt; </td></tr>
<tr class="memitem:adee50533ace388403bdc966d2326dfaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adee50533ace388403bdc966d2326dfaa">std::rotate</a> (_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last)</td></tr>
<tr class="memdesc:adee50533ace388403bdc966d2326dfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:adee50533ace388403bdc966d2326dfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03a04d32db35b5303c8f86e2d7a6fc0" id="r_ab03a04d32db35b5303c8f86e2d7a6fc0"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:ab03a04d32db35b5303c8f86e2d7a6fc0"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab03a04d32db35b5303c8f86e2d7a6fc0">std::rotate_copy</a> (_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last, _OutputIter __result)</td></tr>
<tr class="memdesc:ab03a04d32db35b5303c8f86e2d7a6fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:ab03a04d32db35b5303c8f86e2d7a6fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135859f4aa5feeb64c35996749ad20b8" id="r_a135859f4aa5feeb64c35996749ad20b8"><td class="memTemplParams" colspan="2">template&lt;typename _Distance &gt; </td></tr>
<tr class="memitem:a135859f4aa5feeb64c35996749ad20b8"><td class="memTemplItemLeft" align="right" valign="top">_Distance&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a135859f4aa5feeb64c35996749ad20b8">std::__random_number</a> (_Distance __n)</td></tr>
<tr class="separator:a135859f4aa5feeb64c35996749ad20b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad193f1aa0572896d4405c913fe447f70" id="r_ad193f1aa0572896d4405c913fe447f70"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter &gt; </td></tr>
<tr class="memitem:ad193f1aa0572896d4405c913fe447f70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad193f1aa0572896d4405c913fe447f70">std::random_shuffle</a> (_RandomAccessIter __first, _RandomAccessIter __last)</td></tr>
<tr class="memdesc:ad193f1aa0572896d4405c913fe447f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:ad193f1aa0572896d4405c913fe447f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5009c68ad7fe85f9b07b7cb8ee8c0b34" id="r_a5009c68ad7fe85f9b07b7cb8ee8c0b34"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _RandomNumberGenerator &gt; </td></tr>
<tr class="memitem:a5009c68ad7fe85f9b07b7cb8ee8c0b34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5009c68ad7fe85f9b07b7cb8ee8c0b34">std::random_shuffle</a> (_RandomAccessIter __first, _RandomAccessIter __last, _RandomNumberGenerator &amp;__rand)</td></tr>
<tr class="memdesc:a5009c68ad7fe85f9b07b7cb8ee8c0b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:a5009c68ad7fe85f9b07b7cb8ee8c0b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0e85f6206455ac02f3c7ab5c6be2e9" id="r_afa0e85f6206455ac02f3c7ab5c6be2e9"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Predicate &gt; </td></tr>
<tr class="memitem:afa0e85f6206455ac02f3c7ab5c6be2e9"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afa0e85f6206455ac02f3c7ab5c6be2e9">std::__partition</a> (_ForwardIter __first, _ForwardIter __last, _Predicate __pred, <a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a>)</td></tr>
<tr class="separator:afa0e85f6206455ac02f3c7ab5c6be2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf2209c4ec4a710fca2ef8aa199fdd2" id="r_abbf2209c4ec4a710fca2ef8aa199fdd2"><td class="memTemplParams" colspan="2">template&lt;typename _BidirectionalIter , typename _Predicate &gt; </td></tr>
<tr class="memitem:abbf2209c4ec4a710fca2ef8aa199fdd2"><td class="memTemplItemLeft" align="right" valign="top">_BidirectionalIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abbf2209c4ec4a710fca2ef8aa199fdd2">std::__partition</a> (_BidirectionalIter __first, _BidirectionalIter __last, _Predicate __pred, <a class="el" href="structstd_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a>)</td></tr>
<tr class="separator:abbf2209c4ec4a710fca2ef8aa199fdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cf45b5022ae502a153f28441e363f3" id="r_af8cf45b5022ae502a153f28441e363f3"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Predicate &gt; </td></tr>
<tr class="memitem:af8cf45b5022ae502a153f28441e363f3"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8cf45b5022ae502a153f28441e363f3">std::partition</a> (_ForwardIter __first, _ForwardIter __last, _Predicate __pred)</td></tr>
<tr class="memdesc:af8cf45b5022ae502a153f28441e363f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:af8cf45b5022ae502a153f28441e363f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229a2ec863a39bae3475d44cb8fb8c14" id="r_a229a2ec863a39bae3475d44cb8fb8c14"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Predicate , typename _Distance &gt; </td></tr>
<tr class="memitem:a229a2ec863a39bae3475d44cb8fb8c14"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a229a2ec863a39bae3475d44cb8fb8c14">std::__inplace_stable_partition</a> (_ForwardIter __first, _ForwardIter __last, _Predicate __pred, _Distance __len)</td></tr>
<tr class="separator:a229a2ec863a39bae3475d44cb8fb8c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3b23390d22a10d0ebdf50404de0b80" id="r_a7f3b23390d22a10d0ebdf50404de0b80"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Pointer , typename _Predicate , typename _Distance &gt; </td></tr>
<tr class="memitem:a7f3b23390d22a10d0ebdf50404de0b80"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f3b23390d22a10d0ebdf50404de0b80">std::__stable_partition_adaptive</a> (_ForwardIter __first, _ForwardIter __last, _Predicate __pred, _Distance __len, _Pointer __buffer, _Distance __buffer_size)</td></tr>
<tr class="separator:a7f3b23390d22a10d0ebdf50404de0b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e34bc01ec5d062747f0f2b4a1e181e" id="r_ac3e34bc01ec5d062747f0f2b4a1e181e"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Predicate &gt; </td></tr>
<tr class="memitem:ac3e34bc01ec5d062747f0f2b4a1e181e"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3e34bc01ec5d062747f0f2b4a1e181e">std::stable_partition</a> (_ForwardIter __first, _ForwardIter __last, _Predicate __pred)</td></tr>
<tr class="memdesc:ac3e34bc01ec5d062747f0f2b4a1e181e"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:ac3e34bc01ec5d062747f0f2b4a1e181e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca7e111462e72162755a7d11fbbecc7" id="r_a6ca7e111462e72162755a7d11fbbecc7"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Tp &gt; </td></tr>
<tr class="memitem:a6ca7e111462e72162755a7d11fbbecc7"><td class="memTemplItemLeft" align="right" valign="top">_RandomAccessIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ca7e111462e72162755a7d11fbbecc7">std::__unguarded_partition</a> (_RandomAccessIter __first, _RandomAccessIter __last, _Tp __pivot)</td></tr>
<tr class="separator:a6ca7e111462e72162755a7d11fbbecc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f35a4c9f140321ec0a57ef7c61abdcc" id="r_a3f35a4c9f140321ec0a57ef7c61abdcc"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:a3f35a4c9f140321ec0a57ef7c61abdcc"><td class="memTemplItemLeft" align="right" valign="top">_RandomAccessIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f35a4c9f140321ec0a57ef7c61abdcc">std::__unguarded_partition</a> (_RandomAccessIter __first, _RandomAccessIter __last, _Tp __pivot, _Compare __comp)</td></tr>
<tr class="separator:a3f35a4c9f140321ec0a57ef7c61abdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd0894b4dceaf8399be3510a4a67ae7" id="r_a5cd0894b4dceaf8399be3510a4a67ae7"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Tp &gt; </td></tr>
<tr class="memitem:a5cd0894b4dceaf8399be3510a4a67ae7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5cd0894b4dceaf8399be3510a4a67ae7">std::__unguarded_linear_insert</a> (_RandomAccessIter __last, _Tp __val)</td></tr>
<tr class="separator:a5cd0894b4dceaf8399be3510a4a67ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38175cbb997d5dad0c2518da905d187" id="r_af38175cbb997d5dad0c2518da905d187"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:af38175cbb997d5dad0c2518da905d187"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af38175cbb997d5dad0c2518da905d187">std::__unguarded_linear_insert</a> (_RandomAccessIter __last, _Tp __val, _Compare __comp)</td></tr>
<tr class="separator:af38175cbb997d5dad0c2518da905d187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebc1b5dc778d39fe6e6ce7c4dc1bb55" id="r_a4ebc1b5dc778d39fe6e6ce7c4dc1bb55"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter &gt; </td></tr>
<tr class="memitem:a4ebc1b5dc778d39fe6e6ce7c4dc1bb55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ebc1b5dc778d39fe6e6ce7c4dc1bb55">std::__insertion_sort</a> (_RandomAccessIter __first, _RandomAccessIter __last)</td></tr>
<tr class="separator:a4ebc1b5dc778d39fe6e6ce7c4dc1bb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565d1ed0ea6dcc328f9e4d33f30ce315" id="r_a565d1ed0ea6dcc328f9e4d33f30ce315"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a565d1ed0ea6dcc328f9e4d33f30ce315"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a565d1ed0ea6dcc328f9e4d33f30ce315">std::__insertion_sort</a> (_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)</td></tr>
<tr class="separator:a565d1ed0ea6dcc328f9e4d33f30ce315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2dba395fe4b1cdc96f18b36e272727" id="r_a8a2dba395fe4b1cdc96f18b36e272727"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter &gt; </td></tr>
<tr class="memitem:a8a2dba395fe4b1cdc96f18b36e272727"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a2dba395fe4b1cdc96f18b36e272727">std::__unguarded_insertion_sort</a> (_RandomAccessIter __first, _RandomAccessIter __last)</td></tr>
<tr class="separator:a8a2dba395fe4b1cdc96f18b36e272727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29d53bd4c600516466f5a3ee3f7c957" id="r_ae29d53bd4c600516466f5a3ee3f7c957"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Compare &gt; </td></tr>
<tr class="memitem:ae29d53bd4c600516466f5a3ee3f7c957"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae29d53bd4c600516466f5a3ee3f7c957">std::__unguarded_insertion_sort</a> (_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)</td></tr>
<tr class="separator:ae29d53bd4c600516466f5a3ee3f7c957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea320f6ab5e22e92bcdb5f79a9fa7ba1" id="r_aea320f6ab5e22e92bcdb5f79a9fa7ba1"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter &gt; </td></tr>
<tr class="memitem:aea320f6ab5e22e92bcdb5f79a9fa7ba1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea320f6ab5e22e92bcdb5f79a9fa7ba1">std::__final_insertion_sort</a> (_RandomAccessIter __first, _RandomAccessIter __last)</td></tr>
<tr class="separator:aea320f6ab5e22e92bcdb5f79a9fa7ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d4dd8e21994591229f7438b20af1f8" id="r_ad8d4dd8e21994591229f7438b20af1f8"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Compare &gt; </td></tr>
<tr class="memitem:ad8d4dd8e21994591229f7438b20af1f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad8d4dd8e21994591229f7438b20af1f8">std::__final_insertion_sort</a> (_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)</td></tr>
<tr class="separator:ad8d4dd8e21994591229f7438b20af1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ef32f13ce4492ac2189b796f429407" id="r_ae7ef32f13ce4492ac2189b796f429407"><td class="memTemplParams" colspan="2">template&lt;typename _Size &gt; </td></tr>
<tr class="memitem:ae7ef32f13ce4492ac2189b796f429407"><td class="memTemplItemLeft" align="right" valign="top">_Size&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae7ef32f13ce4492ac2189b796f429407">std::__lg</a> (_Size __n)</td></tr>
<tr class="separator:ae7ef32f13ce4492ac2189b796f429407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb981090258cb2ede33a41ecb38215a1" id="r_afb981090258cb2ede33a41ecb38215a1"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Size &gt; </td></tr>
<tr class="memitem:afb981090258cb2ede33a41ecb38215a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb981090258cb2ede33a41ecb38215a1">std::__introsort_loop</a> (_RandomAccessIter __first, _RandomAccessIter __last, _Size __depth_limit)</td></tr>
<tr class="separator:afb981090258cb2ede33a41ecb38215a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609df20c68ef5e02cfdf098d6782819f" id="r_a609df20c68ef5e02cfdf098d6782819f"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Size , typename _Compare &gt; </td></tr>
<tr class="memitem:a609df20c68ef5e02cfdf098d6782819f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a609df20c68ef5e02cfdf098d6782819f">std::__introsort_loop</a> (_RandomAccessIter __first, _RandomAccessIter __last, _Size __depth_limit, _Compare __comp)</td></tr>
<tr class="separator:a609df20c68ef5e02cfdf098d6782819f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f88116827e184b865de0de03e2339aa" id="r_a4f88116827e184b865de0de03e2339aa"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter &gt; </td></tr>
<tr class="memitem:a4f88116827e184b865de0de03e2339aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f88116827e184b865de0de03e2339aa">std::sort</a> (_RandomAccessIter __first, _RandomAccessIter __last)</td></tr>
<tr class="memdesc:a4f88116827e184b865de0de03e2339aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:a4f88116827e184b865de0de03e2339aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44870bbb6ed594cc47aaab9e86d7c75d" id="r_a44870bbb6ed594cc47aaab9e86d7c75d"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a44870bbb6ed594cc47aaab9e86d7c75d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a44870bbb6ed594cc47aaab9e86d7c75d">std::sort</a> (_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)</td></tr>
<tr class="memdesc:a44870bbb6ed594cc47aaab9e86d7c75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:a44870bbb6ed594cc47aaab9e86d7c75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3638740e340cce3d7f849c62850ed73e" id="r_a3638740e340cce3d7f849c62850ed73e"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter &gt; </td></tr>
<tr class="memitem:a3638740e340cce3d7f849c62850ed73e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3638740e340cce3d7f849c62850ed73e">std::__inplace_stable_sort</a> (_RandomAccessIter __first, _RandomAccessIter __last)</td></tr>
<tr class="separator:a3638740e340cce3d7f849c62850ed73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b59dcc5794cadf2268a1932ade2cac" id="r_a81b59dcc5794cadf2268a1932ade2cac"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a81b59dcc5794cadf2268a1932ade2cac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a81b59dcc5794cadf2268a1932ade2cac">std::__inplace_stable_sort</a> (_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)</td></tr>
<tr class="separator:a81b59dcc5794cadf2268a1932ade2cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297a138a35d374ae85df6ebff7f32f14" id="r_a297a138a35d374ae85df6ebff7f32f14"><td class="memTemplParams" colspan="2"><a id="a297a138a35d374ae85df6ebff7f32f14" name="a297a138a35d374ae85df6ebff7f32f14"></a>
template&lt;typename _RandomAccessIter1 , typename _RandomAccessIter2 , typename _Distance &gt; </td></tr>
<tr class="memitem:a297a138a35d374ae85df6ebff7f32f14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__merge_sort_loop</b> (_RandomAccessIter1 __first, _RandomAccessIter1 __last, _RandomAccessIter2 __result, _Distance __step_size)</td></tr>
<tr class="separator:a297a138a35d374ae85df6ebff7f32f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139fbc7150395a205dc03ad6bd5ac475" id="r_a139fbc7150395a205dc03ad6bd5ac475"><td class="memTemplParams" colspan="2"><a id="a139fbc7150395a205dc03ad6bd5ac475" name="a139fbc7150395a205dc03ad6bd5ac475"></a>
template&lt;typename _RandomAccessIter1 , typename _RandomAccessIter2 , typename _Distance , typename _Compare &gt; </td></tr>
<tr class="memitem:a139fbc7150395a205dc03ad6bd5ac475"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__merge_sort_loop</b> (_RandomAccessIter1 __first, _RandomAccessIter1 __last, _RandomAccessIter2 __result, _Distance __step_size, _Compare __comp)</td></tr>
<tr class="separator:a139fbc7150395a205dc03ad6bd5ac475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb319c7dc936c8bd154cb162eff0117" id="r_a0eb319c7dc936c8bd154cb162eff0117"><td class="memTemplParams" colspan="2"><a id="a0eb319c7dc936c8bd154cb162eff0117" name="a0eb319c7dc936c8bd154cb162eff0117"></a>
template&lt;typename _RandomAccessIter , typename _Distance &gt; </td></tr>
<tr class="memitem:a0eb319c7dc936c8bd154cb162eff0117"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__chunk_insertion_sort</b> (_RandomAccessIter __first, _RandomAccessIter __last, _Distance __chunk_size)</td></tr>
<tr class="separator:a0eb319c7dc936c8bd154cb162eff0117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c78ab8418d5230935cf4b6c0099568" id="r_af6c78ab8418d5230935cf4b6c0099568"><td class="memTemplParams" colspan="2"><a id="af6c78ab8418d5230935cf4b6c0099568" name="af6c78ab8418d5230935cf4b6c0099568"></a>
template&lt;typename _RandomAccessIter , typename _Distance , typename _Compare &gt; </td></tr>
<tr class="memitem:af6c78ab8418d5230935cf4b6c0099568"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__chunk_insertion_sort</b> (_RandomAccessIter __first, _RandomAccessIter __last, _Distance __chunk_size, _Compare __comp)</td></tr>
<tr class="separator:af6c78ab8418d5230935cf4b6c0099568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d3d4c649e2d651e65bba12dd2c25c3" id="r_a11d3d4c649e2d651e65bba12dd2c25c3"><td class="memTemplParams" colspan="2"><a id="a11d3d4c649e2d651e65bba12dd2c25c3" name="a11d3d4c649e2d651e65bba12dd2c25c3"></a>
template&lt;typename _RandomAccessIter , typename _Pointer &gt; </td></tr>
<tr class="memitem:a11d3d4c649e2d651e65bba12dd2c25c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__merge_sort_with_buffer</b> (_RandomAccessIter __first, _RandomAccessIter __last, _Pointer __buffer)</td></tr>
<tr class="separator:a11d3d4c649e2d651e65bba12dd2c25c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc16996a43e2244c6925ecaf09ebf85" id="r_abdc16996a43e2244c6925ecaf09ebf85"><td class="memTemplParams" colspan="2"><a id="abdc16996a43e2244c6925ecaf09ebf85" name="abdc16996a43e2244c6925ecaf09ebf85"></a>
template&lt;typename _RandomAccessIter , typename _Pointer , typename _Compare &gt; </td></tr>
<tr class="memitem:abdc16996a43e2244c6925ecaf09ebf85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__merge_sort_with_buffer</b> (_RandomAccessIter __first, _RandomAccessIter __last, _Pointer __buffer, _Compare __comp)</td></tr>
<tr class="separator:abdc16996a43e2244c6925ecaf09ebf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2904570018107f088ee5995b4a3e2fab" id="r_a2904570018107f088ee5995b4a3e2fab"><td class="memTemplParams" colspan="2"><a id="a2904570018107f088ee5995b4a3e2fab" name="a2904570018107f088ee5995b4a3e2fab"></a>
template&lt;typename _RandomAccessIter , typename _Pointer , typename _Distance &gt; </td></tr>
<tr class="memitem:a2904570018107f088ee5995b4a3e2fab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__stable_sort_adaptive</b> (_RandomAccessIter __first, _RandomAccessIter __last, _Pointer __buffer, _Distance __buffer_size)</td></tr>
<tr class="separator:a2904570018107f088ee5995b4a3e2fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2b31604636b18fca9dc1613dca2e22" id="r_a8a2b31604636b18fca9dc1613dca2e22"><td class="memTemplParams" colspan="2"><a id="a8a2b31604636b18fca9dc1613dca2e22" name="a8a2b31604636b18fca9dc1613dca2e22"></a>
template&lt;typename _RandomAccessIter , typename _Pointer , typename _Distance , typename _Compare &gt; </td></tr>
<tr class="memitem:a8a2b31604636b18fca9dc1613dca2e22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__stable_sort_adaptive</b> (_RandomAccessIter __first, _RandomAccessIter __last, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)</td></tr>
<tr class="separator:a8a2b31604636b18fca9dc1613dca2e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ce6cb181a2d38a23a3d13fc0e0a7c3" id="r_a07ce6cb181a2d38a23a3d13fc0e0a7c3"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter &gt; </td></tr>
<tr class="memitem:a07ce6cb181a2d38a23a3d13fc0e0a7c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07ce6cb181a2d38a23a3d13fc0e0a7c3">std::stable_sort</a> (_RandomAccessIter __first, _RandomAccessIter __last)</td></tr>
<tr class="memdesc:a07ce6cb181a2d38a23a3d13fc0e0a7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:a07ce6cb181a2d38a23a3d13fc0e0a7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d575791f4353a53b891c776e46791de" id="r_a3d575791f4353a53b891c776e46791de"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a3d575791f4353a53b891c776e46791de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d575791f4353a53b891c776e46791de">std::stable_sort</a> (_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)</td></tr>
<tr class="memdesc:a3d575791f4353a53b891c776e46791de"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:a3d575791f4353a53b891c776e46791de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af412bbdc5a369e1509ab5b6272c49932" id="r_af412bbdc5a369e1509ab5b6272c49932"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter &gt; </td></tr>
<tr class="memitem:af412bbdc5a369e1509ab5b6272c49932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af412bbdc5a369e1509ab5b6272c49932">std::partial_sort</a> (_RandomAccessIter __first, _RandomAccessIter __middle, _RandomAccessIter __last)</td></tr>
<tr class="memdesc:af412bbdc5a369e1509ab5b6272c49932"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:af412bbdc5a369e1509ab5b6272c49932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d0eca76779114b625a25b988996c71" id="r_a05d0eca76779114b625a25b988996c71"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a05d0eca76779114b625a25b988996c71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05d0eca76779114b625a25b988996c71">std::partial_sort</a> (_RandomAccessIter __first, _RandomAccessIter __middle, _RandomAccessIter __last, _Compare __comp)</td></tr>
<tr class="memdesc:a05d0eca76779114b625a25b988996c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:a05d0eca76779114b625a25b988996c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd7d5b601295a962d4e4389e45a45fd" id="r_a0fd7d5b601295a962d4e4389e45a45fd"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _RandomAccessIter &gt; </td></tr>
<tr class="memitem:a0fd7d5b601295a962d4e4389e45a45fd"><td class="memTemplItemLeft" align="right" valign="top">_RandomAccessIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0fd7d5b601295a962d4e4389e45a45fd">std::partial_sort_copy</a> (_InputIter __first, _InputIter __last, _RandomAccessIter __result_first, _RandomAccessIter __result_last)</td></tr>
<tr class="memdesc:a0fd7d5b601295a962d4e4389e45a45fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:a0fd7d5b601295a962d4e4389e45a45fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5298c1902771f15fdb60433f5735d584" id="r_a5298c1902771f15fdb60433f5735d584"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _RandomAccessIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a5298c1902771f15fdb60433f5735d584"><td class="memTemplItemLeft" align="right" valign="top">_RandomAccessIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5298c1902771f15fdb60433f5735d584">std::partial_sort_copy</a> (_InputIter __first, _InputIter __last, _RandomAccessIter __result_first, _RandomAccessIter __result_last, _Compare __comp)</td></tr>
<tr class="memdesc:a5298c1902771f15fdb60433f5735d584"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:a5298c1902771f15fdb60433f5735d584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f267e3e019a563910535f5c473051b" id="r_a11f267e3e019a563910535f5c473051b"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter &gt; </td></tr>
<tr class="memitem:a11f267e3e019a563910535f5c473051b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a11f267e3e019a563910535f5c473051b">std::nth_element</a> (_RandomAccessIter __first, _RandomAccessIter __nth, _RandomAccessIter __last)</td></tr>
<tr class="memdesc:a11f267e3e019a563910535f5c473051b"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:a11f267e3e019a563910535f5c473051b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad348212fcf6463ef878985da78bd6a75" id="r_ad348212fcf6463ef878985da78bd6a75"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIter , typename _Compare &gt; </td></tr>
<tr class="memitem:ad348212fcf6463ef878985da78bd6a75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad348212fcf6463ef878985da78bd6a75">std::nth_element</a> (_RandomAccessIter __first, _RandomAccessIter __nth, _RandomAccessIter __last, _Compare __comp)</td></tr>
<tr class="memdesc:ad348212fcf6463ef878985da78bd6a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:ad348212fcf6463ef878985da78bd6a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc003acf846e355c5d109dda012d5f6" id="r_a6fc003acf846e355c5d109dda012d5f6"><td class="memTemplParams" colspan="2"><a id="a6fc003acf846e355c5d109dda012d5f6" name="a6fc003acf846e355c5d109dda012d5f6"></a>
template&lt;typename _ForwardIter , typename _Tp &gt; </td></tr>
<tr class="memitem:a6fc003acf846e355c5d109dda012d5f6"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::lower_bound</b> (_ForwardIter __first, _ForwardIter __last, const _Tp &amp;__val)</td></tr>
<tr class="separator:a6fc003acf846e355c5d109dda012d5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99edd080eb4587973f25ac9ccad493b" id="r_aa99edd080eb4587973f25ac9ccad493b"><td class="memTemplParams" colspan="2"><a id="aa99edd080eb4587973f25ac9ccad493b" name="aa99edd080eb4587973f25ac9ccad493b"></a>
template&lt;typename _ForwardIter , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:aa99edd080eb4587973f25ac9ccad493b"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::lower_bound</b> (_ForwardIter __first, _ForwardIter __last, const _Tp &amp;__val, _Compare __comp)</td></tr>
<tr class="separator:aa99edd080eb4587973f25ac9ccad493b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b46541efc1062f9025aae1c7ba3bf61" id="r_a9b46541efc1062f9025aae1c7ba3bf61"><td class="memTemplParams" colspan="2"><a id="a9b46541efc1062f9025aae1c7ba3bf61" name="a9b46541efc1062f9025aae1c7ba3bf61"></a>
template&lt;typename _ForwardIter , typename _Tp &gt; </td></tr>
<tr class="memitem:a9b46541efc1062f9025aae1c7ba3bf61"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::upper_bound</b> (_ForwardIter __first, _ForwardIter __last, const _Tp &amp;__val)</td></tr>
<tr class="separator:a9b46541efc1062f9025aae1c7ba3bf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a92fb53a5a1e9d0d7dd72ae395acd4" id="r_a05a92fb53a5a1e9d0d7dd72ae395acd4"><td class="memTemplParams" colspan="2"><a id="a05a92fb53a5a1e9d0d7dd72ae395acd4" name="a05a92fb53a5a1e9d0d7dd72ae395acd4"></a>
template&lt;typename _ForwardIter , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:a05a92fb53a5a1e9d0d7dd72ae395acd4"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::upper_bound</b> (_ForwardIter __first, _ForwardIter __last, const _Tp &amp;__val, _Compare __comp)</td></tr>
<tr class="separator:a05a92fb53a5a1e9d0d7dd72ae395acd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2287d7a0e78418558cdd87a7c453e6ae" id="r_a2287d7a0e78418558cdd87a7c453e6ae"><td class="memTemplParams" colspan="2"><a id="a2287d7a0e78418558cdd87a7c453e6ae" name="a2287d7a0e78418558cdd87a7c453e6ae"></a>
template&lt;typename _ForwardIter , typename _Tp &gt; </td></tr>
<tr class="memitem:a2287d7a0e78418558cdd87a7c453e6ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1pair.html">pair</a>&lt; _ForwardIter, _ForwardIter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::equal_range</b> (_ForwardIter __first, _ForwardIter __last, const _Tp &amp;__val)</td></tr>
<tr class="separator:a2287d7a0e78418558cdd87a7c453e6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab101958e30a06e8e60e8a6bbaea038c3" id="r_ab101958e30a06e8e60e8a6bbaea038c3"><td class="memTemplParams" colspan="2"><a id="ab101958e30a06e8e60e8a6bbaea038c3" name="ab101958e30a06e8e60e8a6bbaea038c3"></a>
template&lt;typename _ForwardIter , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:ab101958e30a06e8e60e8a6bbaea038c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1pair.html">pair</a>&lt; _ForwardIter, _ForwardIter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::equal_range</b> (_ForwardIter __first, _ForwardIter __last, const _Tp &amp;__val, _Compare __comp)</td></tr>
<tr class="separator:ab101958e30a06e8e60e8a6bbaea038c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddd87461f82fbf39f889440feea72a7" id="r_a2ddd87461f82fbf39f889440feea72a7"><td class="memTemplParams" colspan="2"><a id="a2ddd87461f82fbf39f889440feea72a7" name="a2ddd87461f82fbf39f889440feea72a7"></a>
template&lt;typename _ForwardIter , typename _Tp &gt; </td></tr>
<tr class="memitem:a2ddd87461f82fbf39f889440feea72a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::binary_search</b> (_ForwardIter __first, _ForwardIter __last, const _Tp &amp;__val)</td></tr>
<tr class="separator:a2ddd87461f82fbf39f889440feea72a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b0ba3cecbc0af279792d5e1584e287" id="r_a71b0ba3cecbc0af279792d5e1584e287"><td class="memTemplParams" colspan="2"><a id="a71b0ba3cecbc0af279792d5e1584e287" name="a71b0ba3cecbc0af279792d5e1584e287"></a>
template&lt;typename _ForwardIter , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:a71b0ba3cecbc0af279792d5e1584e287"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::binary_search</b> (_ForwardIter __first, _ForwardIter __last, const _Tp &amp;__val, _Compare __comp)</td></tr>
<tr class="separator:a71b0ba3cecbc0af279792d5e1584e287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e0a8bc5883ef53c3e5e07062acb18c" id="r_a83e0a8bc5883ef53c3e5e07062acb18c"><td class="memTemplParams" colspan="2"><a id="a83e0a8bc5883ef53c3e5e07062acb18c" name="a83e0a8bc5883ef53c3e5e07062acb18c"></a>
template&lt;typename _InputIter1 , typename _InputIter2 , typename _OutputIter &gt; </td></tr>
<tr class="memitem:a83e0a8bc5883ef53c3e5e07062acb18c"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::merge</b> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _OutputIter __result)</td></tr>
<tr class="separator:a83e0a8bc5883ef53c3e5e07062acb18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2f8f0b81da04f53d9740ed4aa7c6c1" id="r_a7f2f8f0b81da04f53d9740ed4aa7c6c1"><td class="memTemplParams" colspan="2"><a id="a7f2f8f0b81da04f53d9740ed4aa7c6c1" name="a7f2f8f0b81da04f53d9740ed4aa7c6c1"></a>
template&lt;typename _InputIter1 , typename _InputIter2 , typename _OutputIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a7f2f8f0b81da04f53d9740ed4aa7c6c1"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::merge</b> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _OutputIter __result, _Compare __comp)</td></tr>
<tr class="separator:a7f2f8f0b81da04f53d9740ed4aa7c6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae099b9590aa39cf472128956bdb7b025" id="r_ae099b9590aa39cf472128956bdb7b025"><td class="memTemplParams" colspan="2"><a id="ae099b9590aa39cf472128956bdb7b025" name="ae099b9590aa39cf472128956bdb7b025"></a>
template&lt;typename _BidirectionalIter , typename _Distance &gt; </td></tr>
<tr class="memitem:ae099b9590aa39cf472128956bdb7b025"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__merge_without_buffer</b> (_BidirectionalIter __first, _BidirectionalIter __middle, _BidirectionalIter __last, _Distance __len1, _Distance __len2)</td></tr>
<tr class="separator:ae099b9590aa39cf472128956bdb7b025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b13f063d540a81a34e3bad413711226" id="r_a5b13f063d540a81a34e3bad413711226"><td class="memTemplParams" colspan="2"><a id="a5b13f063d540a81a34e3bad413711226" name="a5b13f063d540a81a34e3bad413711226"></a>
template&lt;typename _BidirectionalIter , typename _Distance , typename _Compare &gt; </td></tr>
<tr class="memitem:a5b13f063d540a81a34e3bad413711226"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__merge_without_buffer</b> (_BidirectionalIter __first, _BidirectionalIter __middle, _BidirectionalIter __last, _Distance __len1, _Distance __len2, _Compare __comp)</td></tr>
<tr class="separator:a5b13f063d540a81a34e3bad413711226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0737e904a45c136ff63d91adcbc829b" id="r_ab0737e904a45c136ff63d91adcbc829b"><td class="memTemplParams" colspan="2"><a id="ab0737e904a45c136ff63d91adcbc829b" name="ab0737e904a45c136ff63d91adcbc829b"></a>
template&lt;typename _BidirectionalIter1 , typename _BidirectionalIter2 , typename _Distance &gt; </td></tr>
<tr class="memitem:ab0737e904a45c136ff63d91adcbc829b"><td class="memTemplItemLeft" align="right" valign="top">_BidirectionalIter1&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__rotate_adaptive</b> (_BidirectionalIter1 __first, _BidirectionalIter1 __middle, _BidirectionalIter1 __last, _Distance __len1, _Distance __len2, _BidirectionalIter2 __buffer, _Distance __buffer_size)</td></tr>
<tr class="separator:ab0737e904a45c136ff63d91adcbc829b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba22376991369a863cbb375a76e69175" id="r_aba22376991369a863cbb375a76e69175"><td class="memTemplParams" colspan="2"><a id="aba22376991369a863cbb375a76e69175" name="aba22376991369a863cbb375a76e69175"></a>
template&lt;typename _BidirectionalIter1 , typename _BidirectionalIter2 , typename _BidirectionalIter3 &gt; </td></tr>
<tr class="memitem:aba22376991369a863cbb375a76e69175"><td class="memTemplItemLeft" align="right" valign="top">_BidirectionalIter3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__merge_backward</b> (_BidirectionalIter1 __first1, _BidirectionalIter1 __last1, _BidirectionalIter2 __first2, _BidirectionalIter2 __last2, _BidirectionalIter3 __result)</td></tr>
<tr class="separator:aba22376991369a863cbb375a76e69175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1fd5a5c659d3660a1f33d753416dcb" id="r_a3e1fd5a5c659d3660a1f33d753416dcb"><td class="memTemplParams" colspan="2"><a id="a3e1fd5a5c659d3660a1f33d753416dcb" name="a3e1fd5a5c659d3660a1f33d753416dcb"></a>
template&lt;typename _BidirectionalIter1 , typename _BidirectionalIter2 , typename _BidirectionalIter3 , typename _Compare &gt; </td></tr>
<tr class="memitem:a3e1fd5a5c659d3660a1f33d753416dcb"><td class="memTemplItemLeft" align="right" valign="top">_BidirectionalIter3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__merge_backward</b> (_BidirectionalIter1 __first1, _BidirectionalIter1 __last1, _BidirectionalIter2 __first2, _BidirectionalIter2 __last2, _BidirectionalIter3 __result, _Compare __comp)</td></tr>
<tr class="separator:a3e1fd5a5c659d3660a1f33d753416dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74211dad6c5bab08ec68716e5ad9223a" id="r_a74211dad6c5bab08ec68716e5ad9223a"><td class="memTemplParams" colspan="2"><a id="a74211dad6c5bab08ec68716e5ad9223a" name="a74211dad6c5bab08ec68716e5ad9223a"></a>
template&lt;typename _BidirectionalIter , typename _Distance , typename _Pointer &gt; </td></tr>
<tr class="memitem:a74211dad6c5bab08ec68716e5ad9223a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__merge_adaptive</b> (_BidirectionalIter __first, _BidirectionalIter __middle, _BidirectionalIter __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size)</td></tr>
<tr class="separator:a74211dad6c5bab08ec68716e5ad9223a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505afc32fe57e8dc87b2bd2bd13fcd8c" id="r_a505afc32fe57e8dc87b2bd2bd13fcd8c"><td class="memTemplParams" colspan="2"><a id="a505afc32fe57e8dc87b2bd2bd13fcd8c" name="a505afc32fe57e8dc87b2bd2bd13fcd8c"></a>
template&lt;typename _BidirectionalIter , typename _Distance , typename _Pointer , typename _Compare &gt; </td></tr>
<tr class="memitem:a505afc32fe57e8dc87b2bd2bd13fcd8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__merge_adaptive</b> (_BidirectionalIter __first, _BidirectionalIter __middle, _BidirectionalIter __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)</td></tr>
<tr class="separator:a505afc32fe57e8dc87b2bd2bd13fcd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e283ff690429c38641fc6324adc614" id="r_a37e283ff690429c38641fc6324adc614"><td class="memTemplParams" colspan="2"><a id="a37e283ff690429c38641fc6324adc614" name="a37e283ff690429c38641fc6324adc614"></a>
template&lt;typename _BidirectionalIter &gt; </td></tr>
<tr class="memitem:a37e283ff690429c38641fc6324adc614"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::inplace_merge</b> (_BidirectionalIter __first, _BidirectionalIter __middle, _BidirectionalIter __last)</td></tr>
<tr class="separator:a37e283ff690429c38641fc6324adc614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920976f4a33d3963afee7d9cb7cdac86" id="r_a920976f4a33d3963afee7d9cb7cdac86"><td class="memTemplParams" colspan="2"><a id="a920976f4a33d3963afee7d9cb7cdac86" name="a920976f4a33d3963afee7d9cb7cdac86"></a>
template&lt;typename _BidirectionalIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a920976f4a33d3963afee7d9cb7cdac86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::inplace_merge</b> (_BidirectionalIter __first, _BidirectionalIter __middle, _BidirectionalIter __last, _Compare __comp)</td></tr>
<tr class="separator:a920976f4a33d3963afee7d9cb7cdac86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900db0c18d49a1e52cd12993a9fb37bc" id="r_a900db0c18d49a1e52cd12993a9fb37bc"><td class="memTemplParams" colspan="2"><a id="a900db0c18d49a1e52cd12993a9fb37bc" name="a900db0c18d49a1e52cd12993a9fb37bc"></a>
template&lt;typename _InputIter1 , typename _InputIter2 &gt; </td></tr>
<tr class="memitem:a900db0c18d49a1e52cd12993a9fb37bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::includes</b> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2)</td></tr>
<tr class="separator:a900db0c18d49a1e52cd12993a9fb37bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e302b4ae010ee46e6989ee646ba12ae" id="r_a9e302b4ae010ee46e6989ee646ba12ae"><td class="memTemplParams" colspan="2"><a id="a9e302b4ae010ee46e6989ee646ba12ae" name="a9e302b4ae010ee46e6989ee646ba12ae"></a>
template&lt;typename _InputIter1 , typename _InputIter2 , typename _Compare &gt; </td></tr>
<tr class="memitem:a9e302b4ae010ee46e6989ee646ba12ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::includes</b> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _Compare __comp)</td></tr>
<tr class="separator:a9e302b4ae010ee46e6989ee646ba12ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4378943c298797470782600857881dc5" id="r_a4378943c298797470782600857881dc5"><td class="memTemplParams" colspan="2"><a id="a4378943c298797470782600857881dc5" name="a4378943c298797470782600857881dc5"></a>
template&lt;typename _InputIter1 , typename _InputIter2 , typename _OutputIter &gt; </td></tr>
<tr class="memitem:a4378943c298797470782600857881dc5"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::set_union</b> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _OutputIter __result)</td></tr>
<tr class="separator:a4378943c298797470782600857881dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140be702dd17afb0b0018e13d83aaba1" id="r_a140be702dd17afb0b0018e13d83aaba1"><td class="memTemplParams" colspan="2"><a id="a140be702dd17afb0b0018e13d83aaba1" name="a140be702dd17afb0b0018e13d83aaba1"></a>
template&lt;typename _InputIter1 , typename _InputIter2 , typename _OutputIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a140be702dd17afb0b0018e13d83aaba1"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::set_union</b> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _OutputIter __result, _Compare __comp)</td></tr>
<tr class="separator:a140be702dd17afb0b0018e13d83aaba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fffe1cbbf0f8ae06616086ea8f1e93" id="r_ae2fffe1cbbf0f8ae06616086ea8f1e93"><td class="memTemplParams" colspan="2"><a id="ae2fffe1cbbf0f8ae06616086ea8f1e93" name="ae2fffe1cbbf0f8ae06616086ea8f1e93"></a>
template&lt;typename _InputIter1 , typename _InputIter2 , typename _OutputIter &gt; </td></tr>
<tr class="memitem:ae2fffe1cbbf0f8ae06616086ea8f1e93"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::set_intersection</b> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _OutputIter __result)</td></tr>
<tr class="separator:ae2fffe1cbbf0f8ae06616086ea8f1e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7de5702bf9d3ff57f12c237789d253" id="r_a7b7de5702bf9d3ff57f12c237789d253"><td class="memTemplParams" colspan="2"><a id="a7b7de5702bf9d3ff57f12c237789d253" name="a7b7de5702bf9d3ff57f12c237789d253"></a>
template&lt;typename _InputIter1 , typename _InputIter2 , typename _OutputIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a7b7de5702bf9d3ff57f12c237789d253"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::set_intersection</b> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _OutputIter __result, _Compare __comp)</td></tr>
<tr class="separator:a7b7de5702bf9d3ff57f12c237789d253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40786dc42fa136273188c4a0c90c588" id="r_aa40786dc42fa136273188c4a0c90c588"><td class="memTemplParams" colspan="2"><a id="aa40786dc42fa136273188c4a0c90c588" name="aa40786dc42fa136273188c4a0c90c588"></a>
template&lt;typename _InputIter1 , typename _InputIter2 , typename _OutputIter &gt; </td></tr>
<tr class="memitem:aa40786dc42fa136273188c4a0c90c588"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::set_difference</b> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _OutputIter __result)</td></tr>
<tr class="separator:aa40786dc42fa136273188c4a0c90c588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c964fb40691f94c319817d7fcfe4f2f" id="r_a8c964fb40691f94c319817d7fcfe4f2f"><td class="memTemplParams" colspan="2"><a id="a8c964fb40691f94c319817d7fcfe4f2f" name="a8c964fb40691f94c319817d7fcfe4f2f"></a>
template&lt;typename _InputIter1 , typename _InputIter2 , typename _OutputIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a8c964fb40691f94c319817d7fcfe4f2f"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::set_difference</b> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _OutputIter __result, _Compare __comp)</td></tr>
<tr class="separator:a8c964fb40691f94c319817d7fcfe4f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa107f57bcb28afa160d288bc7ef8d0f4" id="r_aa107f57bcb28afa160d288bc7ef8d0f4"><td class="memTemplParams" colspan="2"><a id="aa107f57bcb28afa160d288bc7ef8d0f4" name="aa107f57bcb28afa160d288bc7ef8d0f4"></a>
template&lt;typename _InputIter1 , typename _InputIter2 , typename _OutputIter &gt; </td></tr>
<tr class="memitem:aa107f57bcb28afa160d288bc7ef8d0f4"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::set_symmetric_difference</b> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _OutputIter __result)</td></tr>
<tr class="separator:aa107f57bcb28afa160d288bc7ef8d0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc3cc3a0b36afe859c2d1931c733c97" id="r_aacc3cc3a0b36afe859c2d1931c733c97"><td class="memTemplParams" colspan="2"><a id="aacc3cc3a0b36afe859c2d1931c733c97" name="aacc3cc3a0b36afe859c2d1931c733c97"></a>
template&lt;typename _InputIter1 , typename _InputIter2 , typename _OutputIter , typename _Compare &gt; </td></tr>
<tr class="memitem:aacc3cc3a0b36afe859c2d1931c733c97"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::set_symmetric_difference</b> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _OutputIter __result, _Compare __comp)</td></tr>
<tr class="separator:aacc3cc3a0b36afe859c2d1931c733c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb7accb651496f290d31ee3946afa18" id="r_a0fb7accb651496f290d31ee3946afa18"><td class="memTemplParams" colspan="2"><a id="a0fb7accb651496f290d31ee3946afa18" name="a0fb7accb651496f290d31ee3946afa18"></a>
template&lt;typename _ForwardIter &gt; </td></tr>
<tr class="memitem:a0fb7accb651496f290d31ee3946afa18"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::max_element</b> (_ForwardIter __first, _ForwardIter __last)</td></tr>
<tr class="separator:a0fb7accb651496f290d31ee3946afa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5635f62a7e247c57e7d83e764346a5d5" id="r_a5635f62a7e247c57e7d83e764346a5d5"><td class="memTemplParams" colspan="2"><a id="a5635f62a7e247c57e7d83e764346a5d5" name="a5635f62a7e247c57e7d83e764346a5d5"></a>
template&lt;typename _ForwardIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a5635f62a7e247c57e7d83e764346a5d5"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::max_element</b> (_ForwardIter __first, _ForwardIter __last, _Compare __comp)</td></tr>
<tr class="separator:a5635f62a7e247c57e7d83e764346a5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721d04d1839cc3b01eb68b5b935c7e88" id="r_a721d04d1839cc3b01eb68b5b935c7e88"><td class="memTemplParams" colspan="2"><a id="a721d04d1839cc3b01eb68b5b935c7e88" name="a721d04d1839cc3b01eb68b5b935c7e88"></a>
template&lt;typename _ForwardIter &gt; </td></tr>
<tr class="memitem:a721d04d1839cc3b01eb68b5b935c7e88"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::min_element</b> (_ForwardIter __first, _ForwardIter __last)</td></tr>
<tr class="separator:a721d04d1839cc3b01eb68b5b935c7e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52e84001a6b8b2a1edfd82f37b83f2d" id="r_ad52e84001a6b8b2a1edfd82f37b83f2d"><td class="memTemplParams" colspan="2"><a id="ad52e84001a6b8b2a1edfd82f37b83f2d" name="ad52e84001a6b8b2a1edfd82f37b83f2d"></a>
template&lt;typename _ForwardIter , typename _Compare &gt; </td></tr>
<tr class="memitem:ad52e84001a6b8b2a1edfd82f37b83f2d"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::min_element</b> (_ForwardIter __first, _ForwardIter __last, _Compare __comp)</td></tr>
<tr class="separator:ad52e84001a6b8b2a1edfd82f37b83f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f84c60b3523ccc4d8d833a7e5256c4" id="r_ab3f84c60b3523ccc4d8d833a7e5256c4"><td class="memTemplParams" colspan="2"><a id="ab3f84c60b3523ccc4d8d833a7e5256c4" name="ab3f84c60b3523ccc4d8d833a7e5256c4"></a>
template&lt;typename _BidirectionalIter &gt; </td></tr>
<tr class="memitem:ab3f84c60b3523ccc4d8d833a7e5256c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::next_permutation</b> (_BidirectionalIter __first, _BidirectionalIter __last)</td></tr>
<tr class="separator:ab3f84c60b3523ccc4d8d833a7e5256c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fd55a95d33c574aad2118ecff34415" id="r_a45fd55a95d33c574aad2118ecff34415"><td class="memTemplParams" colspan="2"><a id="a45fd55a95d33c574aad2118ecff34415" name="a45fd55a95d33c574aad2118ecff34415"></a>
template&lt;typename _BidirectionalIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a45fd55a95d33c574aad2118ecff34415"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::next_permutation</b> (_BidirectionalIter __first, _BidirectionalIter __last, _Compare __comp)</td></tr>
<tr class="separator:a45fd55a95d33c574aad2118ecff34415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c37c3b4093d032ce86eaba5d784c1e4" id="r_a3c37c3b4093d032ce86eaba5d784c1e4"><td class="memTemplParams" colspan="2"><a id="a3c37c3b4093d032ce86eaba5d784c1e4" name="a3c37c3b4093d032ce86eaba5d784c1e4"></a>
template&lt;typename _BidirectionalIter &gt; </td></tr>
<tr class="memitem:a3c37c3b4093d032ce86eaba5d784c1e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::prev_permutation</b> (_BidirectionalIter __first, _BidirectionalIter __last)</td></tr>
<tr class="separator:a3c37c3b4093d032ce86eaba5d784c1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854b873fa3394639b4b3d936a9ee9001" id="r_a854b873fa3394639b4b3d936a9ee9001"><td class="memTemplParams" colspan="2"><a id="a854b873fa3394639b4b3d936a9ee9001" name="a854b873fa3394639b4b3d936a9ee9001"></a>
template&lt;typename _BidirectionalIter , typename _Compare &gt; </td></tr>
<tr class="memitem:a854b873fa3394639b4b3d936a9ee9001"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::prev_permutation</b> (_BidirectionalIter __first, _BidirectionalIter __last, _Compare __comp)</td></tr>
<tr class="separator:a854b873fa3394639b4b3d936a9ee9001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8d949e178ddf93a4fc49f2e9f8a9b5" id="r_a6b8d949e178ddf93a4fc49f2e9f8a9b5"><td class="memTemplParams" colspan="2"><a id="a6b8d949e178ddf93a4fc49f2e9f8a9b5" name="a6b8d949e178ddf93a4fc49f2e9f8a9b5"></a>
template&lt;typename _InputIter , typename _ForwardIter &gt; </td></tr>
<tr class="memitem:a6b8d949e178ddf93a4fc49f2e9f8a9b5"><td class="memTemplItemLeft" align="right" valign="top">_InputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::find_first_of</b> (_InputIter __first1, _InputIter __last1, _ForwardIter __first2, _ForwardIter __last2)</td></tr>
<tr class="separator:a6b8d949e178ddf93a4fc49f2e9f8a9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15426c5a28336106766c126b64628ae4" id="r_a15426c5a28336106766c126b64628ae4"><td class="memTemplParams" colspan="2"><a id="a15426c5a28336106766c126b64628ae4" name="a15426c5a28336106766c126b64628ae4"></a>
template&lt;typename _InputIter , typename _ForwardIter , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:a15426c5a28336106766c126b64628ae4"><td class="memTemplItemLeft" align="right" valign="top">_InputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::find_first_of</b> (_InputIter __first1, _InputIter __last1, _ForwardIter __first2, _ForwardIter __last2, _BinaryPredicate __comp)</td></tr>
<tr class="separator:a15426c5a28336106766c126b64628ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc388f5f9a3015fc9ae300f7c7a07e6" id="r_abcc388f5f9a3015fc9ae300f7c7a07e6"><td class="memTemplParams" colspan="2"><a id="abcc388f5f9a3015fc9ae300f7c7a07e6" name="abcc388f5f9a3015fc9ae300f7c7a07e6"></a>
template&lt;typename _ForwardIter1 , typename _ForwardIter2 &gt; </td></tr>
<tr class="memitem:abcc388f5f9a3015fc9ae300f7c7a07e6"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter1&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__find_end</b> (_ForwardIter1 __first1, _ForwardIter1 __last1, _ForwardIter2 __first2, _ForwardIter2 __last2, <a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a>, <a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a>)</td></tr>
<tr class="separator:abcc388f5f9a3015fc9ae300f7c7a07e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72311a4ad0bc5d6effd2ef2ec4e23aa4" id="r_a72311a4ad0bc5d6effd2ef2ec4e23aa4"><td class="memTemplParams" colspan="2"><a id="a72311a4ad0bc5d6effd2ef2ec4e23aa4" name="a72311a4ad0bc5d6effd2ef2ec4e23aa4"></a>
template&lt;typename _ForwardIter1 , typename _ForwardIter2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:a72311a4ad0bc5d6effd2ef2ec4e23aa4"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter1&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__find_end</b> (_ForwardIter1 __first1, _ForwardIter1 __last1, _ForwardIter2 __first2, _ForwardIter2 __last2, <a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a>, <a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a>, _BinaryPredicate __comp)</td></tr>
<tr class="separator:a72311a4ad0bc5d6effd2ef2ec4e23aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946218147f343b130746187a2cc03301" id="r_a946218147f343b130746187a2cc03301"><td class="memTemplParams" colspan="2"><a id="a946218147f343b130746187a2cc03301" name="a946218147f343b130746187a2cc03301"></a>
template&lt;typename _BidirectionalIter1 , typename _BidirectionalIter2 &gt; </td></tr>
<tr class="memitem:a946218147f343b130746187a2cc03301"><td class="memTemplItemLeft" align="right" valign="top">_BidirectionalIter1&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__find_end</b> (_BidirectionalIter1 __first1, _BidirectionalIter1 __last1, _BidirectionalIter2 __first2, _BidirectionalIter2 __last2, <a class="el" href="structstd_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a>, <a class="el" href="structstd_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a>)</td></tr>
<tr class="separator:a946218147f343b130746187a2cc03301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813bd47e441beea26d20f4bb7ee4f101" id="r_a813bd47e441beea26d20f4bb7ee4f101"><td class="memTemplParams" colspan="2"><a id="a813bd47e441beea26d20f4bb7ee4f101" name="a813bd47e441beea26d20f4bb7ee4f101"></a>
template&lt;typename _BidirectionalIter1 , typename _BidirectionalIter2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:a813bd47e441beea26d20f4bb7ee4f101"><td class="memTemplItemLeft" align="right" valign="top">_BidirectionalIter1&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__find_end</b> (_BidirectionalIter1 __first1, _BidirectionalIter1 __last1, _BidirectionalIter2 __first2, _BidirectionalIter2 __last2, <a class="el" href="structstd_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a>, <a class="el" href="structstd_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a>, _BinaryPredicate __comp)</td></tr>
<tr class="separator:a813bd47e441beea26d20f4bb7ee4f101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc6993a9ba0246fb37135bed02fbf0a" id="r_a4bc6993a9ba0246fb37135bed02fbf0a"><td class="memTemplParams" colspan="2"><a id="a4bc6993a9ba0246fb37135bed02fbf0a" name="a4bc6993a9ba0246fb37135bed02fbf0a"></a>
template&lt;typename _ForwardIter1 , typename _ForwardIter2 &gt; </td></tr>
<tr class="memitem:a4bc6993a9ba0246fb37135bed02fbf0a"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter1&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::find_end</b> (_ForwardIter1 __first1, _ForwardIter1 __last1, _ForwardIter2 __first2, _ForwardIter2 __last2)</td></tr>
<tr class="separator:a4bc6993a9ba0246fb37135bed02fbf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad727a3baef7e4cd8b4f92a0c6b1e14e7" id="r_ad727a3baef7e4cd8b4f92a0c6b1e14e7"><td class="memTemplParams" colspan="2"><a id="ad727a3baef7e4cd8b4f92a0c6b1e14e7" name="ad727a3baef7e4cd8b4f92a0c6b1e14e7"></a>
template&lt;typename _ForwardIter1 , typename _ForwardIter2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:ad727a3baef7e4cd8b4f92a0c6b1e14e7"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIter1&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::find_end</b> (_ForwardIter1 __first1, _ForwardIter1 __last1, _ForwardIter2 __first2, _ForwardIter2 __last2, _BinaryPredicate __comp)</td></tr>
<tr class="separator:ad727a3baef7e4cd8b4f92a0c6b1e14e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is an internal header file, included by other library headers. You should not attempt to use it directly. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af72ebc2c525774452cb690f3d9c55318" name="af72ebc2c525774452cb690f3d9c55318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72ebc2c525774452cb690f3d9c55318">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint @doctodo This controls some aspect of the sort routines. @endmaint </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aea320f6ab5e22e92bcdb5f79a9fa7ba1" name="aea320f6ab5e22e92bcdb5f79a9fa7ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea320f6ab5e22e92bcdb5f79a9fa7ba1">&#9670;&#160;</a></span>__final_insertion_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__final_insertion_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the sort routine. @endmaint </p>

</div>
</div>
<a id="ad8d4dd8e21994591229f7438b20af1f8" name="ad8d4dd8e21994591229f7438b20af1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d4dd8e21994591229f7438b20af1f8">&#9670;&#160;</a></span>__final_insertion_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__final_insertion_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the sort routine. @endmaint </p>

</div>
</div>
<a id="a64690c88f80577f3052168f0322749e6" name="a64690c88f80577f3052168f0322749e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64690c88f80577f3052168f0322749e6">&#9670;&#160;</a></span>__gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _EuclideanRingElement &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_EuclideanRingElement std::__gcd </td>
          <td>(</td>
          <td class="paramtype">_EuclideanRingElement</td>          <td class="paramname"><span class="paramname"><em>__m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_EuclideanRingElement</td>          <td class="paramname"><span class="paramname"><em>__n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the rotate algorithm specialized on RAIs. @endmaint </p>

</div>
</div>
<a id="a229a2ec863a39bae3475d44cb8fb8c14" name="a229a2ec863a39bae3475d44cb8fb8c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229a2ec863a39bae3475d44cb8fb8c14">&#9670;&#160;</a></span>__inplace_stable_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Predicate , typename _Distance &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::__inplace_stable_partition </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Distance</td>          <td class="paramname"><span class="paramname"><em>__len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function... @endmaint </p>

</div>
</div>
<a id="a3638740e340cce3d7f849c62850ed73e" name="a3638740e340cce3d7f849c62850ed73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3638740e340cce3d7f849c62850ed73e">&#9670;&#160;</a></span>__inplace_stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__inplace_stable_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the stable sorting routines. @endmaint </p>

</div>
</div>
<a id="a81b59dcc5794cadf2268a1932ade2cac" name="a81b59dcc5794cadf2268a1932ade2cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b59dcc5794cadf2268a1932ade2cac">&#9670;&#160;</a></span>__inplace_stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__inplace_stable_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the stable sorting routines. @endmaint </p>

</div>
</div>
<a id="a4ebc1b5dc778d39fe6e6ce7c4dc1bb55" name="a4ebc1b5dc778d39fe6e6ce7c4dc1bb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebc1b5dc778d39fe6e6ce7c4dc1bb55">&#9670;&#160;</a></span>__insertion_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__insertion_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the sort routine. @endmaint </p>

</div>
</div>
<a id="a565d1ed0ea6dcc328f9e4d33f30ce315" name="a565d1ed0ea6dcc328f9e4d33f30ce315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565d1ed0ea6dcc328f9e4d33f30ce315">&#9670;&#160;</a></span>__insertion_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__insertion_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the sort routine. @endmaint </p>

</div>
</div>
<a id="afb981090258cb2ede33a41ecb38215a1" name="afb981090258cb2ede33a41ecb38215a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb981090258cb2ede33a41ecb38215a1">&#9670;&#160;</a></span>__introsort_loop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__introsort_loop </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Size</td>          <td class="paramname"><span class="paramname"><em>__depth_limit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the sort routine. @endmaint </p>

</div>
</div>
<a id="a609df20c68ef5e02cfdf098d6782819f" name="a609df20c68ef5e02cfdf098d6782819f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609df20c68ef5e02cfdf098d6782819f">&#9670;&#160;</a></span>__introsort_loop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Size , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__introsort_loop </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Size</td>          <td class="paramname"><span class="paramname"><em>__depth_limit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the sort routine. @endmaint </p>

</div>
</div>
<a id="ae7ef32f13ce4492ac2189b796f429407" name="ae7ef32f13ce4492ac2189b796f429407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ef32f13ce4492ac2189b796f429407">&#9670;&#160;</a></span>__lg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Size &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Size std::__lg </td>
          <td>(</td>
          <td class="paramtype">_Size</td>          <td class="paramname"><span class="paramname"><em>__n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@maint This is a helper function for the sort routine. @endmaint </p>

</div>
</div>
<a id="acfafe0f6028944b3d3e046b184ded3d3" name="acfafe0f6028944b3d3e046b184ded3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfafe0f6028944b3d3e046b184ded3d3">&#9670;&#160;</a></span>__median() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; std::__median </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the median of three values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A value. </td></tr>
    <tr><td class="paramname">b</td><td>A value. </td></tr>
    <tr><td class="paramname">c</td><td>A value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of <code>a</code>, <code>b</code> or <code>c</code>.</dd></dl>
<p>If <code>{l</code>,m,n} is some convolution of <code>{a</code>,b,c} such that <code>l&lt;=m&lt;=n</code> then the value returned will be <code>m</code>. This is an SGI extension. </p>

</div>
</div>
<a id="ab268ba304c7e2d8f07ce30437908c9b0" name="ab268ba304c7e2d8f07ce30437908c9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab268ba304c7e2d8f07ce30437908c9b0">&#9670;&#160;</a></span>__median() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; std::__median </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the median of three values using a predicate for comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A value. </td></tr>
    <tr><td class="paramname">b</td><td>A value. </td></tr>
    <tr><td class="paramname">c</td><td>A value. </td></tr>
    <tr><td class="paramname">comp</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of <code>a</code>, <code>b</code> or <code>c</code>.</dd></dl>
<p>If <code>{l</code>,m,n} is some convolution of <code>{a</code>,b,c} such that <code>comp(l,m)</code> and <code>comp(m,n)</code> are both true then the value returned will be <code>m</code>. This is an SGI extension. </p>

</div>
</div>
<a id="abbf2209c4ec4a710fca2ef8aa199fdd2" name="abbf2209c4ec4a710fca2ef8aa199fdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf2209c4ec4a710fca2ef8aa199fdd2">&#9670;&#160;</a></span>__partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIter , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_BidirectionalIter std::__partition </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function... @endmaint </p>

</div>
</div>
<a id="afa0e85f6206455ac02f3c7ab5c6be2e9" name="afa0e85f6206455ac02f3c7ab5c6be2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0e85f6206455ac02f3c7ab5c6be2e9">&#9670;&#160;</a></span>__partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::__partition </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function... @endmaint </p>

</div>
</div>
<a id="a135859f4aa5feeb64c35996749ad20b8" name="a135859f4aa5feeb64c35996749ad20b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135859f4aa5feeb64c35996749ad20b8">&#9670;&#160;</a></span>__random_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Distance &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Distance std::__random_number </td>
          <td>(</td>
          <td class="paramtype">_Distance</td>          <td class="paramname"><span class="paramname"><em>__n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@maint Return a random number in the range [0, __n). This function encapsulates whether we're using rand (part of the standard C library) or lrand48 (not standard, but a much better choice whenever it's available).</p>
<p>XXX There is no corresponding encapsulation fn to seed the generator. @endmaint </p>

</div>
</div>
<a id="a68957c635dfa16775ed66fae422ee6f1" name="a68957c635dfa16775ed66fae422ee6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68957c635dfa16775ed66fae422ee6f1">&#9670;&#160;</a></span>__reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__reverse </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is an uglified reverse(_BidirectionalIter, _BidirectionalIter) overloaded for bidirectional iterators. @endmaint </p>

</div>
</div>
<a id="a295a53399a8d207447498663b887f16d" name="a295a53399a8d207447498663b887f16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295a53399a8d207447498663b887f16d">&#9670;&#160;</a></span>__reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__reverse </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1random__access__iterator__tag.html">random_access_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is an uglified reverse(_BidirectionalIter, _BidirectionalIter) overloaded for bidirectional iterators. @endmaint </p>

</div>
</div>
<a id="af9f211d404ebb9c55a8c42bb8888b3e8" name="af9f211d404ebb9c55a8c42bb8888b3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f211d404ebb9c55a8c42bb8888b3e8">&#9670;&#160;</a></span>__rotate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__rotate </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIter</td>          <td class="paramname"><span class="paramname"><em>__middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the rotate algorithm. @endmaint </p>

</div>
</div>
<a id="a2497f652533c32547f894bea70a07119" name="a2497f652533c32547f894bea70a07119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2497f652533c32547f894bea70a07119">&#9670;&#160;</a></span>__rotate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__rotate </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the rotate algorithm. @endmaint </p>

</div>
</div>
<a id="a2f7ec97a5581f70eb8e903b9537d8acd" name="a2f7ec97a5581f70eb8e903b9537d8acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7ec97a5581f70eb8e903b9537d8acd">&#9670;&#160;</a></span>__rotate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__rotate </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1random__access__iterator__tag.html">random_access_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the rotate algorithm. @endmaint </p>

</div>
</div>
<a id="a7f3b23390d22a10d0ebdf50404de0b80" name="a7f3b23390d22a10d0ebdf50404de0b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3b23390d22a10d0ebdf50404de0b80">&#9670;&#160;</a></span>__stable_partition_adaptive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Pointer , typename _Predicate , typename _Distance &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::__stable_partition_adaptive </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Distance</td>          <td class="paramname"><span class="paramname"><em>__len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Pointer</td>          <td class="paramname"><span class="paramname"><em>__buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Distance</td>          <td class="paramname"><span class="paramname"><em>__buffer_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function... @endmaint </p>

</div>
</div>
<a id="a8a2dba395fe4b1cdc96f18b36e272727" name="a8a2dba395fe4b1cdc96f18b36e272727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2dba395fe4b1cdc96f18b36e272727">&#9670;&#160;</a></span>__unguarded_insertion_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::__unguarded_insertion_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@maint This is a helper function for the sort routine. @endmaint </p>

</div>
</div>
<a id="ae29d53bd4c600516466f5a3ee3f7c957" name="ae29d53bd4c600516466f5a3ee3f7c957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29d53bd4c600516466f5a3ee3f7c957">&#9670;&#160;</a></span>__unguarded_insertion_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::__unguarded_insertion_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@maint This is a helper function for the sort routine. @endmaint </p>

</div>
</div>
<a id="a5cd0894b4dceaf8399be3510a4a67ae7" name="a5cd0894b4dceaf8399be3510a4a67ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd0894b4dceaf8399be3510a4a67ae7">&#9670;&#160;</a></span>__unguarded_linear_insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__unguarded_linear_insert </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Tp</td>          <td class="paramname"><span class="paramname"><em>__val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the sort routine. @endmaint </p>

</div>
</div>
<a id="af38175cbb997d5dad0c2518da905d187" name="af38175cbb997d5dad0c2518da905d187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38175cbb997d5dad0c2518da905d187">&#9670;&#160;</a></span>__unguarded_linear_insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Tp , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::__unguarded_linear_insert </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Tp</td>          <td class="paramname"><span class="paramname"><em>__val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function for the sort routine. @endmaint </p>

</div>
</div>
<a id="a6ca7e111462e72162755a7d11fbbecc7" name="a6ca7e111462e72162755a7d11fbbecc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca7e111462e72162755a7d11fbbecc7">&#9670;&#160;</a></span>__unguarded_partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_RandomAccessIter std::__unguarded_partition </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Tp</td>          <td class="paramname"><span class="paramname"><em>__pivot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function... @endmaint </p>

</div>
</div>
<a id="a3f35a4c9f140321ec0a57ef7c61abdcc" name="a3f35a4c9f140321ec0a57ef7c61abdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f35a4c9f140321ec0a57ef7c61abdcc">&#9670;&#160;</a></span>__unguarded_partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Tp , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_RandomAccessIter std::__unguarded_partition </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Tp</td>          <td class="paramname"><span class="paramname"><em>__pivot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is a helper function... @endmaint </p>

</div>
</div>
<a id="a42c16e74048f162a1761c70819a5e2c3" name="a42c16e74048f162a1761c70819a5e2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c16e74048f162a1761c70819a5e2c3">&#9670;&#160;</a></span>__unique_copy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _ForwardIter , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::__unique_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate</td>          <td class="paramname"><span class="paramname"><em>__binary_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is an uglified unique_copy(_InputIter, _InputIter, _OutputIter, _BinaryPredicate) overloaded for forward iterators. @endmaint </p>

</div>
</div>
<a id="a373709bf00c6344ff9c4faeda775f0e7" name="a373709bf00c6344ff9c4faeda775f0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373709bf00c6344ff9c4faeda775f0e7">&#9670;&#160;</a></span>__unique_copy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _ForwardIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::__unique_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is an uglified unique_copy(_InputIter, _InputIter, _OutputIter) overloaded for forward iterators. @endmaint </p>

</div>
</div>
<a id="a68504549419625d2b27e25fb29cd6e4a" name="a68504549419625d2b27e25fb29cd6e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68504549419625d2b27e25fb29cd6e4a">&#9670;&#160;</a></span>__unique_copy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _OutputIter , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::__unique_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate</td>          <td class="paramname"><span class="paramname"><em>__binary_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1output__iterator__tag.html">output_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is an uglified unique_copy(_InputIter, _InputIter, _OutputIter, _BinaryPredicate) overloaded for output iterators. @endmaint </p>

</div>
</div>
<a id="a7aa07440e73b6aac197ae036f0d60014" name="a7aa07440e73b6aac197ae036f0d60014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa07440e73b6aac197ae036f0d60014">&#9670;&#160;</a></span>__unique_copy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _OutputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::__unique_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1output__iterator__tag.html">output_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is an uglified unique_copy(_InputIter, _InputIter, _OutputIter) overloaded for output iterators. @endmaint </p>

</div>
</div>
<a id="a12db853751ef756b2bdb6c059677e522" name="a12db853751ef756b2bdb6c059677e522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12db853751ef756b2bdb6c059677e522">&#9670;&#160;</a></span>adjacent_find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find two adjacent values in a sequence that are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code></code>[first,last) and such that <code>*i</code> == <code>*</code>(i+1), or <code>last</code> if no such iterator exists. </dd></dl>

</div>
</div>
<a id="a7221da3df1fbdc5460d1c11dc294ca7c" name="a7221da3df1fbdc5460d1c11dc294ca7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7221da3df1fbdc5460d1c11dc294ca7c">&#9670;&#160;</a></span>adjacent_find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate</td>          <td class="paramname"><span class="paramname"><em>__binary_pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find two adjacent values in a sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code></code>[first,last) and such that <code>binary_pred</code>(*i,*(i+1)) is true, or <code>last</code> if no such iterator exists. </dd></dl>

</div>
</div>
<a id="a9cd50872b0adb3f2567455aee86b4ffb" name="a9cd50872b0adb3f2567455aee86b4ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd50872b0adb3f2567455aee86b4ffb">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator_traits&lt; _InputIter &gt;::difference_type std::count </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of copies of a value in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterators <code>i</code> in the range <code></code>[first,last) for which <code>*i</code> == <code>value</code> </dd></dl>

</div>
</div>
<a id="af6f00d011c331e2aae5c2a04b4e19c5d" name="af6f00d011c331e2aae5c2a04b4e19c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f00d011c331e2aae5c2a04b4e19c5d">&#9670;&#160;</a></span>count_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator_traits&lt; _InputIter &gt;::difference_type std::count_if </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the elements of a sequence for which a predicate is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterators <code>i</code> in the range <code></code>[first,last) for which <code>pred(*i)</code> is true. </dd></dl>

</div>
</div>
<a id="aec58dba3311501c8d67b08ed021befd6" name="aec58dba3311501c8d67b08ed021befd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec58dba3311501c8d67b08ed021befd6">&#9670;&#160;</a></span>find() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_InputIter std::find </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a value in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[first,last) such that <code>*i</code> == <code>val</code>, or <code>last</code> if no such iterator exists. </dd></dl>

</div>
</div>
<a id="ae8edd66dd0a134f061c106e256e55e47" name="ae8edd66dd0a134f061c106e256e55e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8edd66dd0a134f061c106e256e55e47">&#9670;&#160;</a></span>find() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_InputIter std::find </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1input__iterator__tag.html">input_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@maint This is an overload used by find() for the Input Iterator case. @endmaint </p>

</div>
</div>
<a id="ad24761c8bdc546aac768fbda09b80208" name="ad24761c8bdc546aac768fbda09b80208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24761c8bdc546aac768fbda09b80208">&#9670;&#160;</a></span>find() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_RandomAccessIter std::find </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1random__access__iterator__tag.html">random_access_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is an overload used by find() for the RAI case. @endmaint </p>

</div>
</div>
<a id="a1210ba14a5ed7e9cbdef76d974fb9cbb" name="a1210ba14a5ed7e9cbdef76d974fb9cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1210ba14a5ed7e9cbdef76d974fb9cbb">&#9670;&#160;</a></span>find_if() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_InputIter std::find_if </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first element in a sequence for which a predicate is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[first,last) such that <code>pred(*i)</code> is true, or <code>last</code> if no such iterator exists. </dd></dl>

</div>
</div>
<a id="a2f8d9cc1e16f0a3abc5fbd6652e78680" name="a2f8d9cc1e16f0a3abc5fbd6652e78680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8d9cc1e16f0a3abc5fbd6652e78680">&#9670;&#160;</a></span>find_if() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_InputIter std::find_if </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1input__iterator__tag.html">input_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@maint This is an overload used by find_if() for the Input Iterator case. @endmaint </p>

</div>
</div>
<a id="a51ab3570432560da0f4328b6e1493b87" name="a51ab3570432560da0f4328b6e1493b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ab3570432560da0f4328b6e1493b87">&#9670;&#160;</a></span>find_if() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_RandomAccessIter std::find_if </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1random__access__iterator__tag.html">random_access_iterator_tag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@maint This is an overload used by find_if() for the RAI case. @endmaint </p>

</div>
</div>
<a id="a542b04562bb781d328f6f1469d24f330" name="a542b04562bb781d328f6f1469d24f330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542b04562bb781d328f6f1469d24f330">&#9670;&#160;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Function std::for_each </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Function</td>          <td class="paramname"><span class="paramname"><em>__f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a function to every element of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">f</td><td>A unary function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>f</code>.</dd></dl>
<p>Applies the function object <code>f</code> to each element in the range <code></code>[first,last). <code>f</code> must not modify the order of the sequence. If <code>f</code> has a return value it is ignored. </p>

</div>
</div>
<a id="a8d34c40a64f3e7c240dfe9daa32c2593" name="a8d34c40a64f3e7c240dfe9daa32c2593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d34c40a64f3e7c240dfe9daa32c2593">&#9670;&#160;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::generate </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Generator</td>          <td class="paramname"><span class="paramname"><em>__gen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the result of a function object to each value in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">gen</td><td>A function object taking no arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>generate() returns no value.</dd></dl>
<p>Performs the assignment <code>*i</code> = <code>gen()</code> for each <code>i</code> in the range <code></code>[first,last). </p>

</div>
</div>
<a id="a089737e512a7a280895691c17f03ec3b" name="a089737e512a7a280895691c17f03ec3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089737e512a7a280895691c17f03ec3b">&#9670;&#160;</a></span>generate_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _OutputIter , typename _Size , typename _Generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::generate_n </td>
          <td>(</td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Size</td>          <td class="paramname"><span class="paramname"><em>__n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Generator</td>          <td class="paramname"><span class="paramname"><em>__gen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the result of a function object to each value in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">n</td><td>The length of the sequence. </td></tr>
    <tr><td class="paramname">gen</td><td>A function object taking no arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the sequence, <code>first+n</code> </dd></dl>
<p>Performs the assignment <code>*i</code> = <code>gen()</code> for each <code>i</code> in the range <code></code>[first,first+n). </p>

</div>
</div>
<a id="a11f267e3e019a563910535f5c473051b" name="a11f267e3e019a563910535f5c473051b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f267e3e019a563910535f5c473051b">&#9670;&#160;</a></span>nth_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::nth_element </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__nth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="ad348212fcf6463ef878985da78bd6a75" name="ad348212fcf6463ef878985da78bd6a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad348212fcf6463ef878985da78bd6a75">&#9670;&#160;</a></span>nth_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::nth_element </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__nth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="af412bbdc5a369e1509ab5b6272c49932" name="af412bbdc5a369e1509ab5b6272c49932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af412bbdc5a369e1509ab5b6272c49932">&#9670;&#160;</a></span>partial_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::partial_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="a05d0eca76779114b625a25b988996c71" name="a05d0eca76779114b625a25b988996c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d0eca76779114b625a25b988996c71">&#9670;&#160;</a></span>partial_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::partial_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="a0fd7d5b601295a962d4e4389e45a45fd" name="a0fd7d5b601295a962d4e4389e45a45fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd7d5b601295a962d4e4389e45a45fd">&#9670;&#160;</a></span>partial_sort_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _RandomAccessIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_RandomAccessIter std::partial_sort_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__result_first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__result_last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Another input iterator. </td></tr>
    <tr><td class="paramname">result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">result_last</td><td>Another random-access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="a5298c1902771f15fdb60433f5735d584" name="a5298c1902771f15fdb60433f5735d584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5298c1902771f15fdb60433f5735d584">&#9670;&#160;</a></span>partial_sort_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _RandomAccessIter , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_RandomAccessIter std::partial_sort_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__result_first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__result_last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Another input iterator. </td></tr>
    <tr><td class="paramname">result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">result_last</td><td>Another random-access iterator. </td></tr>
    <tr><td class="paramname">comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="af8cf45b5022ae502a153f28441e363f3" name="af8cf45b5022ae502a153f28441e363f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cf45b5022ae502a153f28441e363f3">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::partition </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="ad193f1aa0572896d4405c913fe447f70" name="ad193f1aa0572896d4405c913fe447f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad193f1aa0572896d4405c913fe447f70">&#9670;&#160;</a></span>random_shuffle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::random_shuffle </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="a5009c68ad7fe85f9b07b7cb8ee8c0b34" name="a5009c68ad7fe85f9b07b7cb8ee8c0b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5009c68ad7fe85f9b07b7cb8ee8c0b34">&#9670;&#160;</a></span>random_shuffle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _RandomNumberGenerator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::random_shuffle </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomNumberGenerator &amp;</td>          <td class="paramname"><span class="paramname"><em>__rand</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">rand</td><td>The RNG functor or function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="a8d776a1cc211c394f7bf650240045bb1" name="a8d776a1cc211c394f7bf650240045bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d776a1cc211c394f7bf650240045bb1">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::remove </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove elements from a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>All elements equal to <code>value</code> are removed from the range <code></code>[first,last).</p>
<p>remove() is stable, so the relative order of elements that are not removed is unchanged.</p>
<p>Elements between the end of the resulting sequence and <code>last</code> are still present, but their value is unspecified. </p>

</div>
</div>
<a id="a41f4f64570a6c897ab5e80bdd6f99aa6" name="a41f4f64570a6c897ab5e80bdd6f99aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f4f64570a6c897ab5e80bdd6f99aa6">&#9670;&#160;</a></span>remove_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _OutputIter , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::remove_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a sequence, removing elements of a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[first,last) not equal to <code>value</code> to the range beginning at <code>result</code>. remove_copy() is stable, so the relative order of elements that are copied is unchanged. </p>

</div>
</div>
<a id="a4bdc43e3bac32bdebb3f1ad6274cc129" name="a4bdc43e3bac32bdebb3f1ad6274cc129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdc43e3bac32bdebb3f1ad6274cc129">&#9670;&#160;</a></span>remove_copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _OutputIter , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a sequence, removing elements for which a predicate is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[first,last) for which <code>pred</code> returns true to the range beginning at <code>result</code>.</p>
<p>remove_copy_if() is stable, so the relative order of elements that are copied is unchanged. </p>

</div>
</div>
<a id="ad512bd34540bb7c634080af1b004f852" name="ad512bd34540bb7c634080af1b004f852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad512bd34540bb7c634080af1b004f852">&#9670;&#160;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::remove_if </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove elements from a sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>All elements for which <code>pred</code> returns true are removed from the range <code></code>[first,last).</p>
<p>remove_if() is stable, so the relative order of elements that are not removed is unchanged.</p>
<p>Elements between the end of the resulting sequence and <code>last</code> are still present, but their value is unspecified. </p>

</div>
</div>
<a id="af5666f66f610eace0700f415d19d39ed" name="af5666f66f610eace0700f415d19d39ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5666f66f610eace0700f415d19d39ed">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::replace </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__old_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__new_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace each occurrence of one value in a sequence with another value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">old_value</td><td>The value to be replaced. </td></tr>
    <tr><td class="paramname">new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>replace() returns no value.</dd></dl>
<p>For each iterator <code>i</code> in the range <code></code>[first,last) if <code>*i</code> == <code>old_value</code> then the assignment <code>*i</code> = <code>new_value</code> is performed. </p>

</div>
</div>
<a id="a09b7eae0504409cbaac8679717115bdd" name="a09b7eae0504409cbaac8679717115bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b7eae0504409cbaac8679717115bdd">&#9670;&#160;</a></span>replace_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _OutputIter , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::replace_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__old_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__new_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a sequence, replacing each element of one value with another value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">old_value</td><td>The value to be replaced. </td></tr>
    <tr><td class="paramname">new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence, <code>result+</code>(last-first).</dd></dl>
<p>Copies each element in the input range <code></code>[first,last) to the output range <code></code>[result,result+(last-first)) replacing elements equal to <code>old_value</code> with <code>new_value</code>. </p>

</div>
</div>
<a id="ad9b09d97c77f662fe49b9e9fb8363f18" name="ad9b09d97c77f662fe49b9e9fb8363f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b09d97c77f662fe49b9e9fb8363f18">&#9670;&#160;</a></span>replace_copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _OutputIter , typename _Predicate , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::replace_copy_if </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__new_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a sequence, replacing each value for which a predicate returns true with another value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate. </td></tr>
    <tr><td class="paramname">new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence, <code>result+</code>(last-first).</dd></dl>
<p>Copies each element in the range <code></code>[first,last) to the range <code></code>[result,result+(last-first)) replacing elements for which <code>pred</code> returns true with <code>new_value</code>. </p>

</div>
</div>
<a id="acdc12af221d25bb64e65d04703322e1a" name="acdc12af221d25bb64e65d04703322e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc12af221d25bb64e65d04703322e1a">&#9670;&#160;</a></span>replace_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Predicate , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::replace_if </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__new_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace each value in a sequence for which a predicate returns true with another value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate. </td></tr>
    <tr><td class="paramname">new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>replace_if() returns no value.</dd></dl>
<p>For each iterator <code>i</code> in the range <code></code>[first,last) if <code>pred(*i)</code> is true then the assignment <code>*i</code> = <code>new_value</code> is performed. </p>

</div>
</div>
<a id="aa08e1b92afaac8a1223bba8ccf172973" name="aa08e1b92afaac8a1223bba8ccf172973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08e1b92afaac8a1223bba8ccf172973">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::reverse </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A bidirectional iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reverse() returns no value.</dd></dl>
<p>Reverses the order of the elements in the range <code></code>[first,last), so that the first element becomes the last etc. For every <code>i</code> such that <code>0&lt;=i&lt;=</code>(last-first)/2), <code>reverse()</code> swaps <code>*</code>(first+i) and <code>*</code>(last-(i+1)) </p>

</div>
</div>
<a id="acd8c9651e5104c15a6e3f99c67035998" name="acd8c9651e5104c15a6e3f99c67035998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8c9651e5104c15a6e3f99c67035998">&#9670;&#160;</a></span>reverse_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIter , typename _OutputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::reverse_copy </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a sequence, reversing its elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies the elements in the range <code></code>[first,last) to the range <code></code>[result,result+(last-first)) such that the order of the elements is reversed. For every <code>i</code> such that <code>0&lt;=i&lt;=</code>(last-first), <code>reverse_copy()</code> performs the assignment <code>*</code>(result+(last-first)-i) = *(first+i). The ranges <code></code>[first,last) and <code></code>[result,result+(last-first)) must not overlap. </p>

</div>
</div>
<a id="adee50533ace388403bdc966d2326dfaa" name="adee50533ace388403bdc966d2326dfaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee50533ace388403bdc966d2326dfaa">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::rotate </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">middle</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="ab03a04d32db35b5303c8f86e2d7a6fc0" name="ab03a04d32db35b5303c8f86e2d7a6fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03a04d32db35b5303c8f86e2d7a6fc0">&#9670;&#160;</a></span>rotate_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _OutputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::rotate_copy </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">middle</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="a188534039e6c73cdc85cc67fa885d4d8" name="a188534039e6c73cdc85cc67fa885d4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188534039e6c73cdc85cc67fa885d4d8">&#9670;&#160;</a></span>search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter1 , typename _ForwardIter2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter1 std::search </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter1</td>          <td class="paramname"><span class="paramname"><em>__first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter1</td>          <td class="paramname"><span class="paramname"><em>__last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter2</td>          <td class="paramname"><span class="paramname"><em>__first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter2</td>          <td class="paramname"><span class="paramname"><em>__last2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search a sequence for a matching sub-sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last2</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[first1,last1-(last2-first2)) such that <code>*</code>(i+N) == <code>*</code>(first2+N) for each <code>N</code> in the range <code></code>[0,last2-first2), or <code>last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[first1,last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[first2,last2) and returns an iterator to the first element of the sub-sequence, or <code>last1</code> if the sub-sequence is not found.</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[first1,last1) it must start at a position less than <code>last1-</code>(last2-first2) where <code>last2-first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code></code>[first1,last1-(last2-first2)) </p>

</div>
</div>
<a id="ae9e1cf66ada7e64dcec0df53abdf0098" name="ae9e1cf66ada7e64dcec0df53abdf0098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e1cf66ada7e64dcec0df53abdf0098">&#9670;&#160;</a></span>search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter1 , typename _ForwardIter2 , typename _BinaryPred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter1 std::search </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter1</td>          <td class="paramname"><span class="paramname"><em>__first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter1</td>          <td class="paramname"><span class="paramname"><em>__last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter2</td>          <td class="paramname"><span class="paramname"><em>__first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter2</td>          <td class="paramname"><span class="paramname"><em>__last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPred</td>          <td class="paramname"><span class="paramname"><em>__predicate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search a sequence for a matching sub-sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[first1,last1-(last2-first2)) such that <code>predicate</code>(*(i+N),*(first2+N)) is true for each <code>N</code> in the range <code></code>[0,last2-first2), or <code>last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[first1,last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[first2,last2), using <code>predicate</code> to determine equality, and returns an iterator to the first element of the sub-sequence, or <code>last1</code> if no such iterator exists.</p>
<dl class="section see"><dt>See also</dt><dd>search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2) </dd></dl>

</div>
</div>
<a id="ab9d668a295c3a05426cef757e0d674b9" name="ab9d668a295c3a05426cef757e0d674b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d668a295c3a05426cef757e0d674b9">&#9670;&#160;</a></span>search_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Integer , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::search_n </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Integer</td>          <td class="paramname"><span class="paramname"><em>__count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search a sequence for a number of consecutive values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[first,last-count) such that <code>*</code>(i+N) == <code>val</code> for each <code>N</code> in the range <code></code>[0,count), or <code>last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[first,last) for <code>count</code> consecutive elements equal to <code>val</code>. </p>

</div>
</div>
<a id="a4041a96488aa77dd01a3702c82478248" name="a4041a96488aa77dd01a3702c82478248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4041a96488aa77dd01a3702c82478248">&#9670;&#160;</a></span>search_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Integer , typename _Tp , typename _BinaryPred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::search_n </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Integer</td>          <td class="paramname"><span class="paramname"><em>__count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPred</td>          <td class="paramname"><span class="paramname"><em>__binary_pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search a sequence for a number of consecutive values using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">val</td><td>The value to find. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[first,last-count) such that <code>binary_pred</code>(*(i+N),val) is true for each <code>N</code> in the range <code></code>[0,count), or <code>last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[first,last) for <code>count</code> consecutive elements for which the predicate returns true. </p>

</div>
</div>
<a id="a4f88116827e184b865de0de03e2339aa" name="a4f88116827e184b865de0de03e2339aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f88116827e184b865de0de03e2339aa">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="a44870bbb6ed594cc47aaab9e86d7c75d" name="a44870bbb6ed594cc47aaab9e86d7c75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44870bbb6ed594cc47aaab9e86d7c75d">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="ac3e34bc01ec5d062747f0f2b4a1e181e" name="ac3e34bc01ec5d062747f0f2b4a1e181e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e34bc01ec5d062747f0f2b4a1e181e">&#9670;&#160;</a></span>stable_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::stable_partition </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate</td>          <td class="paramname"><span class="paramname"><em>__pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="a07ce6cb181a2d38a23a3d13fc0e0a7c3" name="a07ce6cb181a2d38a23a3d13fc0e0a7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ce6cb181a2d38a23a3d13fc0e0a7c3">&#9670;&#160;</a></span>stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::stable_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="a3d575791f4353a53b891c776e46791de" name="a3d575791f4353a53b891c776e46791de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d575791f4353a53b891c776e46791de">&#9670;&#160;</a></span>stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIter , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::stable_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>@doctodo </p>

</div>
</div>
<a id="a5a9a484f4e4eb5fd5ca0b32b1e9c0c8e" name="a5a9a484f4e4eb5fd5ca0b32b1e9c0c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9a484f4e4eb5fd5ca0b32b1e9c0c8e">&#9670;&#160;</a></span>swap_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter1 , typename _ForwardIter2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter2 std::swap_ranges </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter1</td>          <td class="paramname"><span class="paramname"><em>__first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter1</td>          <td class="paramname"><span class="paramname"><em>__last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter2</td>          <td class="paramname"><span class="paramname"><em>__first2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the elements of two sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">first2</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator equal to <code>first2+</code>(last1-first1).</dd></dl>
<p>Swaps each element in the range <code></code>[first1,last1) with the corresponding element in the range <code></code>[first2,(last1-first1)). The ranges must not overlap. </p>

</div>
</div>
<a id="a4692cff18c740e185497f8c8250e59c5" name="a4692cff18c740e185497f8c8250e59c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4692cff18c740e185497f8c8250e59c5">&#9670;&#160;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _OutputIter , typename _UnaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::transform </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_UnaryOperation</td>          <td class="paramname"><span class="paramname"><em>__unary_op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an operation on a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">unary_op</td><td>A unary operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>result+</code>(last-first).</dd></dl>
<p>Applies the operator to each element in the input range and assigns the results to successive elements of the output sequence. Evaluates <code>*</code>(result+N)=unary_op(*(first+N)) for each <code>N</code> in the range <code></code>[0,last-first).</p>
<p><code>unary_op</code> must not alter its argument. </p>

</div>
</div>
<a id="a55206a338db443b81119946d0b58bbc3" name="a55206a338db443b81119946d0b58bbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55206a338db443b81119946d0b58bbc3">&#9670;&#160;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter1 , typename _InputIter2 , typename _OutputIter , typename _BinaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::transform </td>
          <td>(</td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter2</td>          <td class="paramname"><span class="paramname"><em>__first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryOperation</td>          <td class="paramname"><span class="paramname"><em>__binary_op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an operation on corresponding elements of two sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">binary_op</td><td>A binary operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>result+</code>(last-first).</dd></dl>
<p>Applies the operator to the corresponding elements in the two input ranges and assigns the results to successive elements of the output sequence. Evaluates <code>*</code>(result+N)=binary_op(*(first1+N),*(first2+N)) for each <code>N</code> in the range <code></code>[0,last1-first1).</p>
<p><code>binary_op</code> must not alter either of its arguments. </p>

</div>
</div>
<a id="a83abb7a55b261ebfbcb77a2a7378241d" name="a83abb7a55b261ebfbcb77a2a7378241d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83abb7a55b261ebfbcb77a2a7378241d">&#9670;&#160;</a></span>unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::unique </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove consecutive duplicate values from a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Removes all but the first element from each group of consecutive values that compare equal. unique() is stable, so the relative order of elements that are not removed is unchanged. Elements between the end of the resulting sequence and <code>last</code> are still present, but their value is unspecified. </p>

</div>
</div>
<a id="a38c8d86db4df6c86a04b071c27cb1c7c" name="a38c8d86db4df6c86a04b071c27cb1c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c8d86db4df6c86a04b071c27cb1c7c">&#9670;&#160;</a></span>unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIter std::unique </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate</td>          <td class="paramname"><span class="paramname"><em>__binary_pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove consecutive values from a sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Removes all but the first element from each group of consecutive values for which <code>binary_pred</code> returns true. unique() is stable, so the relative order of elements that are not removed is unchanged. Elements between the end of the resulting sequence and <code>last</code> are still present, but their value is unspecified. </p>

</div>
</div>
<a id="ae39def218a9f4e3d769ef94c14f76346" name="ae39def218a9f4e3d769ef94c14f76346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39def218a9f4e3d769ef94c14f76346">&#9670;&#160;</a></span>unique_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _OutputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::unique_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a sequence, removing consecutive duplicate values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[first,last) to the range beginning at <code>result</code>, except that only the first element is copied from groups of consecutive elements that compare equal. </p>

</div>
</div>
<a id="adac8e7887baf1130e364901ed4f66cfb" name="adac8e7887baf1130e364901ed4f66cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac8e7887baf1130e364901ed4f66cfb">&#9670;&#160;</a></span>unique_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _OutputIter , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::unique_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate</td>          <td class="paramname"><span class="paramname"><em>__binary_pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a sequence, removing consecutive values using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[first,last) to the range beginning at <code>result</code>, except that only the first element is copied from groups of consecutive elements for which <code>binary_pred</code> returns true. unique_copy() is stable, so the relative order of elements that are copied is unchanged. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
