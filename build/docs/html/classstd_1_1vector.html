<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenRadical: std::vector&lt; _Tp, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenRadical
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>std</b></li><li class="navelem"><a class="el" href="classstd_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">std::vector&lt; _Tp, _Alloc &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A standard container which offers fixed time access to individual elements in any order.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stl__vector_8h_source.html">stl_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for std::vector&lt; _Tp, _Alloc &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classstd_1_1vector.png" usemap="#std::vector_3C_20_5FTp_2C_20_5FAlloc_20_3E_map" alt=""/>
  <map id="std::vector_3C_20_5FTp_2C_20_5FAlloc_20_3E_map" name="std::vector_3C_20_5FTp_2C_20_5FAlloc_20_3E_map">
<area href="structstd_1_1__Vector__base.html" alt="std::_Vector_base&lt; _Tp, _Alloc &gt;" shape="rect" coords="0,56,503,80"/>
<area href="classstd_1_1__Vector__alloc__base.html" alt="std::_Vector_alloc_base&lt; _Tp, _Alloc, _Alloc_traits&lt; _Tp, _Alloc &gt;::_S_instanceless &gt;" shape="rect" coords="0,0,503,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1a4cc4a8e6904b3b8a30524313359b23" id="r_a1a4cc4a8e6904b3b8a30524313359b23"><td class="memItemLeft" align="right" valign="top"><a id="a1a4cc4a8e6904b3b8a30524313359b23" name="a1a4cc4a8e6904b3b8a30524313359b23"></a>
typedef _Tp&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a1a4cc4a8e6904b3b8a30524313359b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050082b5bd966f7de734f8e1b8519db0" id="r_a050082b5bd966f7de734f8e1b8519db0"><td class="memItemLeft" align="right" valign="top"><a id="a050082b5bd966f7de734f8e1b8519db0" name="a050082b5bd966f7de734f8e1b8519db0"></a>
typedef value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a050082b5bd966f7de734f8e1b8519db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398cc7be097b34149fc6cc97deff4f65" id="r_a398cc7be097b34149fc6cc97deff4f65"><td class="memItemLeft" align="right" valign="top"><a id="a398cc7be097b34149fc6cc97deff4f65" name="a398cc7be097b34149fc6cc97deff4f65"></a>
typedef const value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a398cc7be097b34149fc6cc97deff4f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad576c0d6a36d7f6cbfe290d59c9352c9" id="r_ad576c0d6a36d7f6cbfe290d59c9352c9"><td class="memItemLeft" align="right" valign="top"><a id="ad576c0d6a36d7f6cbfe290d59c9352c9" name="ad576c0d6a36d7f6cbfe290d59c9352c9"></a>
typedef <a class="el" href="classstd_1_1____normal__iterator.html">__normal_iterator</a>&lt; pointer, vector_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:ad576c0d6a36d7f6cbfe290d59c9352c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3890b794593b5470bef1deb269a63f37" id="r_a3890b794593b5470bef1deb269a63f37"><td class="memItemLeft" align="right" valign="top"><a id="a3890b794593b5470bef1deb269a63f37" name="a3890b794593b5470bef1deb269a63f37"></a>
typedef <a class="el" href="classstd_1_1____normal__iterator.html">__normal_iterator</a>&lt; const_pointer, vector_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a3890b794593b5470bef1deb269a63f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0721eb892d75dbf6dabdd51846549e7" id="r_af0721eb892d75dbf6dabdd51846549e7"><td class="memItemLeft" align="right" valign="top"><a id="af0721eb892d75dbf6dabdd51846549e7" name="af0721eb892d75dbf6dabdd51846549e7"></a>
typedef value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:af0721eb892d75dbf6dabdd51846549e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c6d3df533b0676b9fda231b54aea2a" id="r_a55c6d3df533b0676b9fda231b54aea2a"><td class="memItemLeft" align="right" valign="top"><a id="a55c6d3df533b0676b9fda231b54aea2a" name="a55c6d3df533b0676b9fda231b54aea2a"></a>
typedef const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a55c6d3df533b0676b9fda231b54aea2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2a6bdffbb484e1e7630f0a113e672b" id="r_aba2a6bdffbb484e1e7630f0a113e672b"><td class="memItemLeft" align="right" valign="top"><a id="aba2a6bdffbb484e1e7630f0a113e672b" name="aba2a6bdffbb484e1e7630f0a113e672b"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:aba2a6bdffbb484e1e7630f0a113e672b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bbcb8d42a1a565554fa4d855a2d411" id="r_a91bbcb8d42a1a565554fa4d855a2d411"><td class="memItemLeft" align="right" valign="top"><a id="a91bbcb8d42a1a565554fa4d855a2d411" name="a91bbcb8d42a1a565554fa4d855a2d411"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a91bbcb8d42a1a565554fa4d855a2d411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9d332064b0243acb7d0ca4e9c22a7e" id="r_aab9d332064b0243acb7d0ca4e9c22a7e"><td class="memItemLeft" align="right" valign="top"><a id="aab9d332064b0243acb7d0ca4e9c22a7e" name="aab9d332064b0243acb7d0ca4e9c22a7e"></a>
typedef _Base::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:aab9d332064b0243acb7d0ca4e9c22a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37366b91ee9cc8aa4e44a9e554c8f7e9" id="r_a37366b91ee9cc8aa4e44a9e554c8f7e9"><td class="memItemLeft" align="right" valign="top"><a id="a37366b91ee9cc8aa4e44a9e554c8f7e9" name="a37366b91ee9cc8aa4e44a9e554c8f7e9"></a>
typedef reverse_iterator&lt; <a class="el" href="classstd_1_1____normal__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a37366b91ee9cc8aa4e44a9e554c8f7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141efe7b820519f5f45ea9654f8d19de" id="r_a141efe7b820519f5f45ea9654f8d19de"><td class="memItemLeft" align="right" valign="top"><a id="a141efe7b820519f5f45ea9654f8d19de" name="a141efe7b820519f5f45ea9654f8d19de"></a>
typedef reverse_iterator&lt; <a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a141efe7b820519f5f45ea9654f8d19de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a410aad255e4f779a077da1bb2927d248" id="r_a410aad255e4f779a077da1bb2927d248"><td class="memItemLeft" align="right" valign="top"><a id="a410aad255e4f779a077da1bb2927d248" name="a410aad255e4f779a077da1bb2927d248"></a>
allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const</td></tr>
<tr class="separator:a410aad255e4f779a077da1bb2927d248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e9b3c0d3157f9db067259fc2591085" id="r_a52e9b3c0d3157f9db067259fc2591085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52e9b3c0d3157f9db067259fc2591085">begin</a> ()</td></tr>
<tr class="separator:a52e9b3c0d3157f9db067259fc2591085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e62a2e71e0a9384151027fc9ca2171" id="r_a18e62a2e71e0a9384151027fc9ca2171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1____normal__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18e62a2e71e0a9384151027fc9ca2171">begin</a> () const</td></tr>
<tr class="separator:a18e62a2e71e0a9384151027fc9ca2171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c27a1d92949b353ac4503001c0d1066" id="r_a8c27a1d92949b353ac4503001c0d1066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c27a1d92949b353ac4503001c0d1066">end</a> ()</td></tr>
<tr class="separator:a8c27a1d92949b353ac4503001c0d1066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3288b5084d6368b9ef500b062f1ec1" id="r_a2c3288b5084d6368b9ef500b062f1ec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1____normal__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c3288b5084d6368b9ef500b062f1ec1">end</a> () const</td></tr>
<tr class="separator:a2c3288b5084d6368b9ef500b062f1ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae317a81cb77cdb08432c3a8c00b31df4" id="r_ae317a81cb77cdb08432c3a8c00b31df4"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae317a81cb77cdb08432c3a8c00b31df4">rbegin</a> ()</td></tr>
<tr class="separator:ae317a81cb77cdb08432c3a8c00b31df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f0ba5fd966dcd150343a6ec55da1d0" id="r_ab9f0ba5fd966dcd150343a6ec55da1d0"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f0ba5fd966dcd150343a6ec55da1d0">rbegin</a> () const</td></tr>
<tr class="separator:ab9f0ba5fd966dcd150343a6ec55da1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8471fb4e9eb65ad51ae65a9f06d1570" id="r_aa8471fb4e9eb65ad51ae65a9f06d1570"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8471fb4e9eb65ad51ae65a9f06d1570">rend</a> ()</td></tr>
<tr class="separator:aa8471fb4e9eb65ad51ae65a9f06d1570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad839ae74c295109ecdd0a90990427f67" id="r_ad839ae74c295109ecdd0a90990427f67"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad839ae74c295109ecdd0a90990427f67">rend</a> () const</td></tr>
<tr class="separator:ad839ae74c295109ecdd0a90990427f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74807a76d4c153b95760ed24eaa33fe5" id="r_a74807a76d4c153b95760ed24eaa33fe5"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74807a76d4c153b95760ed24eaa33fe5">size</a> () const</td></tr>
<tr class="separator:a74807a76d4c153b95760ed24eaa33fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4030be0c7bf6bc47457ae59e758c576d" id="r_a4030be0c7bf6bc47457ae59e758c576d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4030be0c7bf6bc47457ae59e758c576d">max_size</a> () const</td></tr>
<tr class="separator:a4030be0c7bf6bc47457ae59e758c576d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ddc1db13e6d5e40ddff24ea4b438b3" id="r_af3ddc1db13e6d5e40ddff24ea4b438b3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3ddc1db13e6d5e40ddff24ea4b438b3">capacity</a> () const</td></tr>
<tr class="separator:af3ddc1db13e6d5e40ddff24ea4b438b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac807b774ac5421066f830687dd2ce923" id="r_ac807b774ac5421066f830687dd2ce923"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac807b774ac5421066f830687dd2ce923">empty</a> () const</td></tr>
<tr class="separator:ac807b774ac5421066f830687dd2ce923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475f606b188e2096932501e97d20ec80" id="r_a475f606b188e2096932501e97d20ec80"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a475f606b188e2096932501e97d20ec80">operator[]</a> (size_type __n)</td></tr>
<tr class="memdesc:a475f606b188e2096932501e97d20ec80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript access to the data contained in the vector.  <br /></td></tr>
<tr class="separator:a475f606b188e2096932501e97d20ec80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e945b9ac9998f33fdcfccf14ba1320" id="r_aa9e945b9ac9998f33fdcfccf14ba1320"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9e945b9ac9998f33fdcfccf14ba1320">operator[]</a> (size_type __n) const</td></tr>
<tr class="memdesc:aa9e945b9ac9998f33fdcfccf14ba1320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript access to the data contained in the vector.  <br /></td></tr>
<tr class="separator:aa9e945b9ac9998f33fdcfccf14ba1320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c7c47a337f0e2dfbdad2c5719c13f5" id="r_a84c7c47a337f0e2dfbdad2c5719c13f5"><td class="memItemLeft" align="right" valign="top"><a id="a84c7c47a337f0e2dfbdad2c5719c13f5" name="a84c7c47a337f0e2dfbdad2c5719c13f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_range_check</b> (size_type __n) const</td></tr>
<tr class="separator:a84c7c47a337f0e2dfbdad2c5719c13f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11362894b61f87331541b5268d0cb033" id="r_a11362894b61f87331541b5268d0cb033"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11362894b61f87331541b5268d0cb033">at</a> (size_type __n)</td></tr>
<tr class="memdesc:a11362894b61f87331541b5268d0cb033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the data contained in the vector.  <br /></td></tr>
<tr class="separator:a11362894b61f87331541b5268d0cb033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0004f67abf317a8923d549a0e74987" id="r_aaa0004f67abf317a8923d549a0e74987"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa0004f67abf317a8923d549a0e74987">at</a> (size_type __n) const</td></tr>
<tr class="memdesc:aaa0004f67abf317a8923d549a0e74987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the data contained in the vector.  <br /></td></tr>
<tr class="separator:aaa0004f67abf317a8923d549a0e74987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada55a3986192464ceca75c983a0de954" id="r_ada55a3986192464ceca75c983a0de954"><td class="memItemLeft" align="right" valign="top"><a id="ada55a3986192464ceca75c983a0de954" name="ada55a3986192464ceca75c983a0de954"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>vector</b> (const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:ada55a3986192464ceca75c983a0de954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68a2b64f697bb84bb5b907f0d87af09" id="r_af68a2b64f697bb84bb5b907f0d87af09"><td class="memItemLeft" align="right" valign="top"><a id="af68a2b64f697bb84bb5b907f0d87af09" name="af68a2b64f697bb84bb5b907f0d87af09"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>vector</b> (size_type __n, const _Tp &amp;__value, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:af68a2b64f697bb84bb5b907f0d87af09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526287c7a31e4452cc3589c79a1ffdf5" id="r_a526287c7a31e4452cc3589c79a1ffdf5"><td class="memItemLeft" align="right" valign="top"><a id="a526287c7a31e4452cc3589c79a1ffdf5" name="a526287c7a31e4452cc3589c79a1ffdf5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>vector</b> (size_type __n)</td></tr>
<tr class="separator:a526287c7a31e4452cc3589c79a1ffdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f6838afc9ccd4b7c12947c92c08ea6" id="r_a89f6838afc9ccd4b7c12947c92c08ea6"><td class="memItemLeft" align="right" valign="top"><a id="a89f6838afc9ccd4b7c12947c92c08ea6" name="a89f6838afc9ccd4b7c12947c92c08ea6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>vector</b> (const <a class="el" href="classstd_1_1vector.html">vector</a>&lt; _Tp, _Alloc &gt; &amp;__x)</td></tr>
<tr class="separator:a89f6838afc9ccd4b7c12947c92c08ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee369dabf3f12977fd45ae93cee1e3c" id="r_a0ee369dabf3f12977fd45ae93cee1e3c"><td class="memTemplParams" colspan="2"><a id="a0ee369dabf3f12977fd45ae93cee1e3c" name="a0ee369dabf3f12977fd45ae93cee1e3c"></a>
template&lt;class _InputIterator &gt; </td></tr>
<tr class="memitem:a0ee369dabf3f12977fd45ae93cee1e3c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector</b> (_InputIterator __first, _InputIterator __last, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:a0ee369dabf3f12977fd45ae93cee1e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746f891d39fcd074a3b027d602e30e6a" id="r_a746f891d39fcd074a3b027d602e30e6a"><td class="memTemplParams" colspan="2"><a id="a746f891d39fcd074a3b027d602e30e6a" name="a746f891d39fcd074a3b027d602e30e6a"></a>
template&lt;class _Integer &gt; </td></tr>
<tr class="memitem:a746f891d39fcd074a3b027d602e30e6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_initialize_aux</b> (_Integer __n, _Integer __value, <a class="el" href="struct____true__type.html">__true_type</a>)</td></tr>
<tr class="separator:a746f891d39fcd074a3b027d602e30e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55336653c228a933e448579551ef0333" id="r_a55336653c228a933e448579551ef0333"><td class="memTemplParams" colspan="2"><a id="a55336653c228a933e448579551ef0333" name="a55336653c228a933e448579551ef0333"></a>
template&lt;class _InputIterator &gt; </td></tr>
<tr class="memitem:a55336653c228a933e448579551ef0333"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_initialize_aux</b> (_InputIterator __first, _InputIterator __last, <a class="el" href="struct____false__type.html">__false_type</a>)</td></tr>
<tr class="separator:a55336653c228a933e448579551ef0333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280453c4679827a70a0e6060f8e61a11" id="r_a280453c4679827a70a0e6060f8e61a11"><td class="memItemLeft" align="right" valign="top"><a id="a280453c4679827a70a0e6060f8e61a11" name="a280453c4679827a70a0e6060f8e61a11"></a>
<a class="el" href="classstd_1_1vector.html">vector</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstd_1_1vector.html">vector</a>&lt; _Tp, _Alloc &gt; &amp;__x)</td></tr>
<tr class="separator:a280453c4679827a70a0e6060f8e61a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ca6994d3b87acac548a110af75fe17" id="r_a82ca6994d3b87acac548a110af75fe17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82ca6994d3b87acac548a110af75fe17">reserve</a> (size_type __n)</td></tr>
<tr class="memdesc:a82ca6994d3b87acac548a110af75fe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to preallocate enough memory for specified number of elements.  <br /></td></tr>
<tr class="separator:a82ca6994d3b87acac548a110af75fe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb86bc5135d98ef2a82300b9364c930" id="r_abcb86bc5135d98ef2a82300b9364c930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcb86bc5135d98ef2a82300b9364c930">assign</a> (size_type __n, const _Tp &amp;__val)</td></tr>
<tr class="memdesc:abcb86bc5135d98ef2a82300b9364c930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a given value or range to a vector.  <br /></td></tr>
<tr class="separator:abcb86bc5135d98ef2a82300b9364c930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8111f01d3de89559a0c3bd7b07667f7c" id="r_a8111f01d3de89559a0c3bd7b07667f7c"><td class="memItemLeft" align="right" valign="top"><a id="a8111f01d3de89559a0c3bd7b07667f7c" name="a8111f01d3de89559a0c3bd7b07667f7c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_fill_assign</b> (size_type __n, const _Tp &amp;__val)</td></tr>
<tr class="separator:a8111f01d3de89559a0c3bd7b07667f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6732e9810e96c93841a564da83f985c9" id="r_a6732e9810e96c93841a564da83f985c9"><td class="memTemplParams" colspan="2"><a id="a6732e9810e96c93841a564da83f985c9" name="a6732e9810e96c93841a564da83f985c9"></a>
template&lt;class _InputIterator &gt; </td></tr>
<tr class="memitem:a6732e9810e96c93841a564da83f985c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (_InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:a6732e9810e96c93841a564da83f985c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f76dd5a06e36e2f216a7a133ea0aa18" id="r_a1f76dd5a06e36e2f216a7a133ea0aa18"><td class="memTemplParams" colspan="2"><a id="a1f76dd5a06e36e2f216a7a133ea0aa18" name="a1f76dd5a06e36e2f216a7a133ea0aa18"></a>
template&lt;class _Integer &gt; </td></tr>
<tr class="memitem:a1f76dd5a06e36e2f216a7a133ea0aa18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_dispatch</b> (_Integer __n, _Integer __val, <a class="el" href="struct____true__type.html">__true_type</a>)</td></tr>
<tr class="separator:a1f76dd5a06e36e2f216a7a133ea0aa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcc90064f9a4e5fbec0f72b0343dcb4" id="r_a6fcc90064f9a4e5fbec0f72b0343dcb4"><td class="memTemplParams" colspan="2"><a id="a6fcc90064f9a4e5fbec0f72b0343dcb4" name="a6fcc90064f9a4e5fbec0f72b0343dcb4"></a>
template&lt;class _InputIter &gt; </td></tr>
<tr class="memitem:a6fcc90064f9a4e5fbec0f72b0343dcb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_dispatch</b> (_InputIter __first, _InputIter __last, <a class="el" href="struct____false__type.html">__false_type</a>)</td></tr>
<tr class="separator:a6fcc90064f9a4e5fbec0f72b0343dcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b18fc7f0ca8a77d7f078bb2447c405" id="r_ac5b18fc7f0ca8a77d7f078bb2447c405"><td class="memTemplParams" colspan="2"><a id="ac5b18fc7f0ca8a77d7f078bb2447c405" name="ac5b18fc7f0ca8a77d7f078bb2447c405"></a>
template&lt;class _InputIterator &gt; </td></tr>
<tr class="memitem:ac5b18fc7f0ca8a77d7f078bb2447c405"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_aux</b> (_InputIterator __first, _InputIterator __last, <a class="el" href="structstd_1_1input__iterator__tag.html">input_iterator_tag</a>)</td></tr>
<tr class="separator:ac5b18fc7f0ca8a77d7f078bb2447c405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8235af7b80d8b8b5fb6f520f27b4dc91" id="r_a8235af7b80d8b8b5fb6f520f27b4dc91"><td class="memTemplParams" colspan="2"><a id="a8235af7b80d8b8b5fb6f520f27b4dc91" name="a8235af7b80d8b8b5fb6f520f27b4dc91"></a>
template&lt;class _ForwardIterator &gt; </td></tr>
<tr class="memitem:a8235af7b80d8b8b5fb6f520f27b4dc91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_aux</b> (_ForwardIterator __first, _ForwardIterator __last, <a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a>)</td></tr>
<tr class="separator:a8235af7b80d8b8b5fb6f520f27b4dc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6430e8ffbe3e8305d90c25e1eb51e97e" id="r_a6430e8ffbe3e8305d90c25e1eb51e97e"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6430e8ffbe3e8305d90c25e1eb51e97e">front</a> ()</td></tr>
<tr class="separator:a6430e8ffbe3e8305d90c25e1eb51e97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c557ad0fef2e563c3796f3b5f41c8b" id="r_ad2c557ad0fef2e563c3796f3b5f41c8b"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2c557ad0fef2e563c3796f3b5f41c8b">front</a> () const</td></tr>
<tr class="separator:ad2c557ad0fef2e563c3796f3b5f41c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9019aa7188e241c10a3fe010cf7f0b" id="r_a3f9019aa7188e241c10a3fe010cf7f0b"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f9019aa7188e241c10a3fe010cf7f0b">back</a> ()</td></tr>
<tr class="separator:a3f9019aa7188e241c10a3fe010cf7f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbac31a3fa1b9424c2a398a28bb466d9" id="r_abbac31a3fa1b9424c2a398a28bb466d9"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbac31a3fa1b9424c2a398a28bb466d9">back</a> () const</td></tr>
<tr class="separator:abbac31a3fa1b9424c2a398a28bb466d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a86f94f795fab625061f1d6d0ef2c8" id="r_a45a86f94f795fab625061f1d6d0ef2c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45a86f94f795fab625061f1d6d0ef2c8">push_back</a> (const _Tp &amp;__x)</td></tr>
<tr class="memdesc:a45a86f94f795fab625061f1d6d0ef2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to the end of the vector.  <br /></td></tr>
<tr class="separator:a45a86f94f795fab625061f1d6d0ef2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff2b03e5855eae37db534957be3b9ae" id="r_a0ff2b03e5855eae37db534957be3b9ae"><td class="memItemLeft" align="right" valign="top"><a id="a0ff2b03e5855eae37db534957be3b9ae" name="a0ff2b03e5855eae37db534957be3b9ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classstd_1_1vector.html">vector</a>&lt; _Tp, _Alloc &gt; &amp;__x)</td></tr>
<tr class="separator:a0ff2b03e5855eae37db534957be3b9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d8e24145553bdcd4a76f08bfd145ca" id="r_a42d8e24145553bdcd4a76f08bfd145ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42d8e24145553bdcd4a76f08bfd145ca">insert</a> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __position, const _Tp &amp;__x)</td></tr>
<tr class="memdesc:a42d8e24145553bdcd4a76f08bfd145ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts given value into vector at specified element.  <br /></td></tr>
<tr class="separator:a42d8e24145553bdcd4a76f08bfd145ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa978f9e360903868118715e1b6ad07d" id="r_afa978f9e360903868118715e1b6ad07d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa978f9e360903868118715e1b6ad07d">insert</a> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __position)</td></tr>
<tr class="memdesc:afa978f9e360903868118715e1b6ad07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an empty element into the vector.  <br /></td></tr>
<tr class="separator:afa978f9e360903868118715e1b6ad07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae894ce3f6b44f4448d47222a19d046f2" id="r_ae894ce3f6b44f4448d47222a19d046f2"><td class="memTemplParams" colspan="2"><a id="ae894ce3f6b44f4448d47222a19d046f2" name="ae894ce3f6b44f4448d47222a19d046f2"></a>
template&lt;class _InputIterator &gt; </td></tr>
<tr class="memitem:ae894ce3f6b44f4448d47222a19d046f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __pos, _InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:ae894ce3f6b44f4448d47222a19d046f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d3c98b4227dd3d0579f5d98a72d0cf" id="r_a11d3c98b4227dd3d0579f5d98a72d0cf"><td class="memTemplParams" colspan="2"><a id="a11d3c98b4227dd3d0579f5d98a72d0cf" name="a11d3c98b4227dd3d0579f5d98a72d0cf"></a>
template&lt;class _Integer &gt; </td></tr>
<tr class="memitem:a11d3c98b4227dd3d0579f5d98a72d0cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_insert_dispatch</b> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __pos, _Integer __n, _Integer __val, <a class="el" href="struct____true__type.html">__true_type</a>)</td></tr>
<tr class="separator:a11d3c98b4227dd3d0579f5d98a72d0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e0b223f26f7ac019b735df1a08a33a" id="r_aa4e0b223f26f7ac019b735df1a08a33a"><td class="memTemplParams" colspan="2"><a id="aa4e0b223f26f7ac019b735df1a08a33a" name="aa4e0b223f26f7ac019b735df1a08a33a"></a>
template&lt;class _InputIterator &gt; </td></tr>
<tr class="memitem:aa4e0b223f26f7ac019b735df1a08a33a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_insert_dispatch</b> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __pos, _InputIterator __first, _InputIterator __last, <a class="el" href="struct____false__type.html">__false_type</a>)</td></tr>
<tr class="separator:aa4e0b223f26f7ac019b735df1a08a33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a469d526e8025d78d810108834203a8" id="r_a4a469d526e8025d78d810108834203a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a469d526e8025d78d810108834203a8">insert</a> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __pos, size_type __n, const _Tp &amp;__x)</td></tr>
<tr class="memdesc:a4a469d526e8025d78d810108834203a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a number of copies of given data into the vector.  <br /></td></tr>
<tr class="separator:a4a469d526e8025d78d810108834203a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046af826e72838870c1240c7a670c7d0" id="r_a046af826e72838870c1240c7a670c7d0"><td class="memItemLeft" align="right" valign="top"><a id="a046af826e72838870c1240c7a670c7d0" name="a046af826e72838870c1240c7a670c7d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_fill_insert</b> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __pos, size_type __n, const _Tp &amp;__x)</td></tr>
<tr class="separator:a046af826e72838870c1240c7a670c7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b162cd471d2baa7ad393c3cd416a59" id="r_a74b162cd471d2baa7ad393c3cd416a59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74b162cd471d2baa7ad393c3cd416a59">pop_back</a> ()</td></tr>
<tr class="memdesc:a74b162cd471d2baa7ad393c3cd416a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes last element from vector.  <br /></td></tr>
<tr class="separator:a74b162cd471d2baa7ad393c3cd416a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab89dc811213d349a842e1182373ce22" id="r_aab89dc811213d349a842e1182373ce22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab89dc811213d349a842e1182373ce22">erase</a> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __position)</td></tr>
<tr class="memdesc:aab89dc811213d349a842e1182373ce22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove element at given position.  <br /></td></tr>
<tr class="separator:aab89dc811213d349a842e1182373ce22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83055425483bc6d737c540279d63af76" id="r_a83055425483bc6d737c540279d63af76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83055425483bc6d737c540279d63af76">erase</a> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __first, <a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __last)</td></tr>
<tr class="memdesc:a83055425483bc6d737c540279d63af76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a range of elements from a vector.  <br /></td></tr>
<tr class="separator:a83055425483bc6d737c540279d63af76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bbf523308970c5c2faf07c457ff488" id="r_aa3bbf523308970c5c2faf07c457ff488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3bbf523308970c5c2faf07c457ff488">resize</a> (size_type __new_size, const _Tp &amp;__x)</td></tr>
<tr class="memdesc:aa3bbf523308970c5c2faf07c457ff488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the vector to the specified number of elements.  <br /></td></tr>
<tr class="separator:aa3bbf523308970c5c2faf07c457ff488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1134bcc83ff6c70cf78bab3cd426feaf" id="r_a1134bcc83ff6c70cf78bab3cd426feaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1134bcc83ff6c70cf78bab3cd426feaf">resize</a> (size_type __new_size)</td></tr>
<tr class="memdesc:a1134bcc83ff6c70cf78bab3cd426feaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the vector to the specified number of elements.  <br /></td></tr>
<tr class="separator:a1134bcc83ff6c70cf78bab3cd426feaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeee7e2ec5ff98c6d75b2c31059189ea" id="r_aaeee7e2ec5ff98c6d75b2c31059189ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaeee7e2ec5ff98c6d75b2c31059189ea">clear</a> ()</td></tr>
<tr class="separator:aaeee7e2ec5ff98c6d75b2c31059189ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9093dae9520b756c75425cb65f41b3cb" id="r_a9093dae9520b756c75425cb65f41b3cb"><td class="memTemplParams" colspan="2"><a id="a9093dae9520b756c75425cb65f41b3cb" name="a9093dae9520b756c75425cb65f41b3cb"></a>
template&lt;class _InputIter &gt; </td></tr>
<tr class="memitem:a9093dae9520b756c75425cb65f41b3cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_aux</b> (_InputIter __first, _InputIter __last, <a class="el" href="structstd_1_1input__iterator__tag.html">input_iterator_tag</a>)</td></tr>
<tr class="separator:a9093dae9520b756c75425cb65f41b3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118b9a2cf9588d7ef0e591511122af56" id="r_a118b9a2cf9588d7ef0e591511122af56"><td class="memTemplParams" colspan="2"><a id="a118b9a2cf9588d7ef0e591511122af56" name="a118b9a2cf9588d7ef0e591511122af56"></a>
template&lt;class _ForwardIter &gt; </td></tr>
<tr class="memitem:a118b9a2cf9588d7ef0e591511122af56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_aux</b> (_ForwardIter __first, _ForwardIter __last, <a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a>)</td></tr>
<tr class="separator:a118b9a2cf9588d7ef0e591511122af56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a74d92b123703785d4a3f6a3b5abaccd2" id="r_a74d92b123703785d4a3f6a3b5abaccd2"><td class="memItemLeft" align="right" valign="top"><a id="a74d92b123703785d4a3f6a3b5abaccd2" name="a74d92b123703785d4a3f6a3b5abaccd2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_insert_aux</b> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __position, const _Tp &amp;__x)</td></tr>
<tr class="separator:a74d92b123703785d4a3f6a3b5abaccd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08db2d8272d43c5dae662fd193a9a545" id="r_a08db2d8272d43c5dae662fd193a9a545"><td class="memItemLeft" align="right" valign="top"><a id="a08db2d8272d43c5dae662fd193a9a545" name="a08db2d8272d43c5dae662fd193a9a545"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_insert_aux</b> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __position)</td></tr>
<tr class="separator:a08db2d8272d43c5dae662fd193a9a545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283e72373f613c3d74ccf35b529a8393" id="r_a283e72373f613c3d74ccf35b529a8393"><td class="memTemplParams" colspan="2"><a id="a283e72373f613c3d74ccf35b529a8393" name="a283e72373f613c3d74ccf35b529a8393"></a>
template&lt;class _ForwardIterator &gt; </td></tr>
<tr class="memitem:a283e72373f613c3d74ccf35b529a8393"><td class="memTemplItemLeft" align="right" valign="top">pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_allocate_and_copy</b> (size_type __n, _ForwardIterator __first, _ForwardIterator __last)</td></tr>
<tr class="separator:a283e72373f613c3d74ccf35b529a8393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a365d0f7b8c35a57c30bb7a24b0e99d" id="r_a0a365d0f7b8c35a57c30bb7a24b0e99d"><td class="memTemplParams" colspan="2"><a id="a0a365d0f7b8c35a57c30bb7a24b0e99d" name="a0a365d0f7b8c35a57c30bb7a24b0e99d"></a>
template&lt;class _InputIterator &gt; </td></tr>
<tr class="memitem:a0a365d0f7b8c35a57c30bb7a24b0e99d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_range_initialize</b> (_InputIterator __first, _InputIterator __last, <a class="el" href="structstd_1_1input__iterator__tag.html">input_iterator_tag</a>)</td></tr>
<tr class="separator:a0a365d0f7b8c35a57c30bb7a24b0e99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973bd2c7218298b38600650bb24651c9" id="r_a973bd2c7218298b38600650bb24651c9"><td class="memTemplParams" colspan="2"><a id="a973bd2c7218298b38600650bb24651c9" name="a973bd2c7218298b38600650bb24651c9"></a>
template&lt;class _ForwardIterator &gt; </td></tr>
<tr class="memitem:a973bd2c7218298b38600650bb24651c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_range_initialize</b> (_ForwardIterator __first, _ForwardIterator __last, <a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a>)</td></tr>
<tr class="separator:a973bd2c7218298b38600650bb24651c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe33ee6900fe85872101fca5b66855c7" id="r_abe33ee6900fe85872101fca5b66855c7"><td class="memTemplParams" colspan="2"><a id="abe33ee6900fe85872101fca5b66855c7" name="abe33ee6900fe85872101fca5b66855c7"></a>
template&lt;class _InputIterator &gt; </td></tr>
<tr class="memitem:abe33ee6900fe85872101fca5b66855c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_range_insert</b> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __pos, _InputIterator __first, _InputIterator __last, <a class="el" href="structstd_1_1input__iterator__tag.html">input_iterator_tag</a>)</td></tr>
<tr class="separator:abe33ee6900fe85872101fca5b66855c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cfa0dd196b86d7224cdb287779c2d4" id="r_a06cfa0dd196b86d7224cdb287779c2d4"><td class="memTemplParams" colspan="2"><a id="a06cfa0dd196b86d7224cdb287779c2d4" name="a06cfa0dd196b86d7224cdb287779c2d4"></a>
template&lt;class _ForwardIterator &gt; </td></tr>
<tr class="memitem:a06cfa0dd196b86d7224cdb287779c2d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_range_insert</b> (<a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> __pos, _ForwardIterator __first, _ForwardIterator __last, <a class="el" href="structstd_1_1forward__iterator__tag.html">forward_iterator_tag</a>)</td></tr>
<tr class="separator:a06cfa0dd196b86d7224cdb287779c2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb89ec60371a25bc83f5047bdaf3b2f" id="r_a1bb89ec60371a25bc83f5047bdaf3b2f"><td class="memItemLeft" align="right" valign="top"><a id="a1bb89ec60371a25bc83f5047bdaf3b2f" name="a1bb89ec60371a25bc83f5047bdaf3b2f"></a>
_Tp *&#160;</td><td class="memItemRight" valign="bottom"><b>_M_allocate</b> (size_t __n)</td></tr>
<tr class="separator:a1bb89ec60371a25bc83f5047bdaf3b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4015605f01be234e5a16d9c672f9cf" id="r_afe4015605f01be234e5a16d9c672f9cf"><td class="memItemLeft" align="right" valign="top"><a id="afe4015605f01be234e5a16d9c672f9cf" name="afe4015605f01be234e5a16d9c672f9cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_deallocate</b> (_Tp *__p, size_t __n)</td></tr>
<tr class="separator:afe4015605f01be234e5a16d9c672f9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_structstd_1_1__Vector__base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_structstd_1_1__Vector__base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="structstd_1_1__Vector__base.html">std::_Vector_base&lt; _Tp, _Alloc &gt;</a></td></tr>
<tr class="memitem:aad60c102e1ea53b70ee8e58fed7a8be0 inherit pro_methods_structstd_1_1__Vector__base" id="r_aad60c102e1ea53b70ee8e58fed7a8be0"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>_Vector_base</b> (const allocator_type &amp;__a)</td></tr>
<tr class="separator:aad60c102e1ea53b70ee8e58fed7a8be0 inherit pro_methods_structstd_1_1__Vector__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7814352b229aece3d013fa60975429 inherit pro_methods_structstd_1_1__Vector__base" id="r_a8f7814352b229aece3d013fa60975429"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>_Vector_base</b> (size_t __n, const allocator_type &amp;__a)</td></tr>
<tr class="separator:a8f7814352b229aece3d013fa60975429 inherit pro_methods_structstd_1_1__Vector__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classstd_1_1__Vector__alloc__base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classstd_1_1__Vector__alloc__base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classstd_1_1__Vector__alloc__base.html">std::_Vector_alloc_base&lt; _Tp, _Alloc, _Alloc_traits&lt; _Tp, _Alloc &gt;::_S_instanceless &gt;</a></td></tr>
<tr class="memitem:a1bb89ec60371a25bc83f5047bdaf3b2f inherit pro_methods_classstd_1_1__Vector__alloc__base" id="r_a1bb89ec60371a25bc83f5047bdaf3b2f"><td class="memItemLeft" align="right" valign="top">
_Tp *&#160;</td><td class="memItemRight" valign="bottom"><b>_M_allocate</b> (size_t __n)</td></tr>
<tr class="separator:a1bb89ec60371a25bc83f5047bdaf3b2f inherit pro_methods_classstd_1_1__Vector__alloc__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4015605f01be234e5a16d9c672f9cf inherit pro_methods_classstd_1_1__Vector__alloc__base" id="r_afe4015605f01be234e5a16d9c672f9cf"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_deallocate</b> (_Tp *__p, size_t __n)</td></tr>
<tr class="separator:afe4015605f01be234e5a16d9c672f9cf inherit pro_methods_classstd_1_1__Vector__alloc__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef1878e11dbc8d1f531f19a2129fdbb inherit pro_methods_classstd_1_1__Vector__alloc__base" id="r_adef1878e11dbc8d1f531f19a2129fdbb"><td class="memItemLeft" align="right" valign="top">
allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const</td></tr>
<tr class="separator:adef1878e11dbc8d1f531f19a2129fdbb inherit pro_methods_classstd_1_1__Vector__alloc__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc983148287d1e468b71d567ea4ecdb inherit pro_methods_classstd_1_1__Vector__alloc__base" id="r_a5cc983148287d1e468b71d567ea4ecdb"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>_Vector_alloc_base</b> (const allocator_type &amp;__a)</td></tr>
<tr class="separator:a5cc983148287d1e468b71d567ea4ecdb inherit pro_methods_classstd_1_1__Vector__alloc__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6b7d1e2390be66e5440dc29bca26ed8f" id="r_a6b7d1e2390be66e5440dc29bca26ed8f"><td class="memItemLeft" align="right" valign="top"><a id="a6b7d1e2390be66e5440dc29bca26ed8f" name="a6b7d1e2390be66e5440dc29bca26ed8f"></a>
_Tp *&#160;</td><td class="memItemRight" valign="bottom"><b>_M_start</b></td></tr>
<tr class="separator:a6b7d1e2390be66e5440dc29bca26ed8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f60d751c4458cbf81ab9e41ce519ba" id="r_a45f60d751c4458cbf81ab9e41ce519ba"><td class="memItemLeft" align="right" valign="top"><a id="a45f60d751c4458cbf81ab9e41ce519ba" name="a45f60d751c4458cbf81ab9e41ce519ba"></a>
_Tp *&#160;</td><td class="memItemRight" valign="bottom"><b>_M_finish</b></td></tr>
<tr class="separator:a45f60d751c4458cbf81ab9e41ce519ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64257a5996facebe970a208b0101b044" id="r_a64257a5996facebe970a208b0101b044"><td class="memItemLeft" align="right" valign="top"><a id="a64257a5996facebe970a208b0101b044" name="a64257a5996facebe970a208b0101b044"></a>
_Tp *&#160;</td><td class="memItemRight" valign="bottom"><b>_M_end_of_storage</b></td></tr>
<tr class="separator:a64257a5996facebe970a208b0101b044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classstd_1_1__Vector__alloc__base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classstd_1_1__Vector__alloc__base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classstd_1_1__Vector__alloc__base.html">std::_Vector_alloc_base&lt; _Tp, _Alloc, _Alloc_traits&lt; _Tp, _Alloc &gt;::_S_instanceless &gt;</a></td></tr>
<tr class="memitem:ae7393227841ba67e7f385b48a7134e2b inherit pro_attribs_classstd_1_1__Vector__alloc__base" id="r_ae7393227841ba67e7f385b48a7134e2b"><td class="memItemLeft" align="right" valign="top">
allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>_M_data_allocator</b></td></tr>
<tr class="separator:ae7393227841ba67e7f385b48a7134e2b inherit pro_attribs_classstd_1_1__Vector__alloc__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7d1e2390be66e5440dc29bca26ed8f inherit pro_attribs_classstd_1_1__Vector__alloc__base" id="r_a6b7d1e2390be66e5440dc29bca26ed8f"><td class="memItemLeft" align="right" valign="top">
_Tp *&#160;</td><td class="memItemRight" valign="bottom"><b>_M_start</b></td></tr>
<tr class="separator:a6b7d1e2390be66e5440dc29bca26ed8f inherit pro_attribs_classstd_1_1__Vector__alloc__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f60d751c4458cbf81ab9e41ce519ba inherit pro_attribs_classstd_1_1__Vector__alloc__base" id="r_a45f60d751c4458cbf81ab9e41ce519ba"><td class="memItemLeft" align="right" valign="top">
_Tp *&#160;</td><td class="memItemRight" valign="bottom"><b>_M_finish</b></td></tr>
<tr class="separator:a45f60d751c4458cbf81ab9e41ce519ba inherit pro_attribs_classstd_1_1__Vector__alloc__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64257a5996facebe970a208b0101b044 inherit pro_attribs_classstd_1_1__Vector__alloc__base" id="r_a64257a5996facebe970a208b0101b044"><td class="memItemLeft" align="right" valign="top">
_Tp *&#160;</td><td class="memItemRight" valign="bottom"><b>_M_end_of_storage</b></td></tr>
<tr class="separator:a64257a5996facebe970a208b0101b044 inherit pro_attribs_classstd_1_1__Vector__alloc__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_structstd_1_1__Vector__base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_types_structstd_1_1__Vector__base')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="structstd_1_1__Vector__base.html">std::_Vector_base&lt; _Tp, _Alloc &gt;</a></td></tr>
<tr class="memitem:a2526ce2782b53c40e7e21541be5675e3 inherit pro_types_structstd_1_1__Vector__base" id="r_a2526ce2782b53c40e7e21541be5675e3"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="classstd_1_1__Vector__alloc__base.html">_Vector_alloc_base</a>&lt; _Tp, _Alloc, <a class="el" href="structstd_1_1__Alloc__traits.html">_Alloc_traits</a>&lt; _Tp, _Alloc &gt;::_S_instanceless &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_Base</b></td></tr>
<tr class="separator:a2526ce2782b53c40e7e21541be5675e3 inherit pro_types_structstd_1_1__Vector__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a78943cb1f6d6b2091ba5881488a2fb inherit pro_types_structstd_1_1__Vector__base" id="r_a9a78943cb1f6d6b2091ba5881488a2fb"><td class="memItemLeft" align="right" valign="top">
typedef _Base::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a9a78943cb1f6d6b2091ba5881488a2fb inherit pro_types_structstd_1_1__Vector__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classstd_1_1__Vector__alloc__base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_types_classstd_1_1__Vector__alloc__base')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classstd_1_1__Vector__alloc__base.html">std::_Vector_alloc_base&lt; _Tp, _Alloc, _Alloc_traits&lt; _Tp, _Alloc &gt;::_S_instanceless &gt;</a></td></tr>
<tr class="memitem:a4c8a91bc27be544fc7c6ce3877106a96 inherit pro_types_classstd_1_1__Vector__alloc__base" id="r_a4c8a91bc27be544fc7c6ce3877106a96"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="structstd_1_1__Alloc__traits.html">_Alloc_traits</a>&lt; _Tp, _Alloc &gt;::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a4c8a91bc27be544fc7c6ce3877106a96 inherit pro_types_classstd_1_1__Vector__alloc__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class _Tp, class _Alloc = allocator&lt;_Tp&gt;&gt;<br />
class std::vector&lt; _Tp, _Alloc &gt;</div><p>A standard container which offers fixed time access to individual elements in any order. </p>
<p>In some terminology a vector can be described as a dynamic C-style array, it offers fast and efficient access to individual elements in any order and saves the user from worrying about memory and size allocation. Subscripting ( [] ) access is also provided as with C-style arrays. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abcb86bc5135d98ef2a82300b9364c930" name="abcb86bc5135d98ef2a82300b9364c930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb86bc5135d98ef2a82300b9364c930">&#9670;&#160;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>__n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a given value or range to a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements to be assigned. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be assigned.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used to assign a range to a vector or fill it with a specified number of copies of the given value. Note that the assignment completely changes the vector and that the resulting vector's size is the same as the number of elements assigned. Old data may be lost. </p>

</div>
</div>
<a id="a11362894b61f87331541b5268d0cb033" name="a11362894b61f87331541b5268d0cb033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11362894b61f87331541b5268d0cb033">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>__n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the data contained in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data.</dd></dl>
<p>This function provides for safer data access. The parameter is first checked that it is in the range of the vector. The function throws out_of_range if the check fails. </p>

</div>
</div>
<a id="aaa0004f67abf317a8923d549a0e74987" name="aaa0004f67abf317a8923d549a0e74987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0004f67abf317a8923d549a0e74987">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>__n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the data contained in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) reference to data.</dd></dl>
<p>This function provides for safer data access. The parameter is first checked that it is in the range of the vector. The function throws out_of_range if the check fails. </p>

</div>
</div>
<a id="a3f9019aa7188e241c10a3fe010cf7f0b" name="a3f9019aa7188e241c10a3fe010cf7f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9019aa7188e241c10a3fe010cf7f0b">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reference to the data at the last element of the vector. </p>

</div>
</div>
<a id="abbac31a3fa1b9424c2a398a28bb466d9" name="abbac31a3fa1b9424c2a398a28bb466d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbac31a3fa1b9424c2a398a28bb466d9">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reference to the data at the first element of the vector. </p>

</div>
</div>
<a id="a52e9b3c0d3157f9db067259fc2591085" name="a52e9b3c0d3157f9db067259fc2591085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e9b3c0d3157f9db067259fc2591085">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points to the first element in the vector. Iteration is done in ordinary element order. </p>

</div>
</div>
<a id="a18e62a2e71e0a9384151027fc9ca2171" name="a18e62a2e71e0a9384151027fc9ca2171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e62a2e71e0a9384151027fc9ca2171">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1____normal__iterator.html">const_iterator</a> <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the vector. Iteration is done in ordinary element order. </p>

</div>
</div>
<a id="af3ddc1db13e6d5e40ddff24ea4b438b3" name="af3ddc1db13e6d5e40ddff24ea4b438b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ddc1db13e6d5e40ddff24ea4b438b3">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the amount of memory that has been alocated for the current elements (?). </p>

</div>
</div>
<a id="aaeee7e2ec5ff98c6d75b2c31059189ea" name="aaeee7e2ec5ff98c6d75b2c31059189ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeee7e2ec5ff98c6d75b2c31059189ea">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all elements in vector. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibilty. </p>

</div>
</div>
<a id="ac807b774ac5421066f830687dd2ce923" name="ac807b774ac5421066f830687dd2ce923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac807b774ac5421066f830687dd2ce923">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the vector is empty. (Thus <a class="el" href="#a52e9b3c0d3157f9db067259fc2591085">begin()</a> would equal <a class="el" href="#a8c27a1d92949b353ac4503001c0d1066">end()</a>.) </p>

</div>
</div>
<a id="a8c27a1d92949b353ac4503001c0d1066" name="a8c27a1d92949b353ac4503001c0d1066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c27a1d92949b353ac4503001c0d1066">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points one past the last element in the vector. Iteration is done in ordinary element order. </p>

</div>
</div>
<a id="a2c3288b5084d6368b9ef500b062f1ec1" name="a2c3288b5084d6368b9ef500b062f1ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3288b5084d6368b9ef500b062f1ec1">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1____normal__iterator.html">const_iterator</a> <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the vector. Iteration is done in ordinary element order. </p>

</div>
</div>
<a id="a83055425483bc6d737c540279d63af76" name="a83055425483bc6d737c540279d63af76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83055425483bc6d737c540279d63af76">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a></td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a></td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a range of elements from a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element to be erased. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Doc Me! (Iterator pointing to new element at old location?)</dd></dl>
<p>This function will erase the elements in the given range and shorten the vector accordingly.</p>
<p>Note This operation could be expensive and if it is frequently used the user should consider using <a class="el" href="classstd_1_1list.html">std::list</a>. The user is also cautioned that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibilty. </p>

</div>
</div>
<a id="aab89dc811213d349a842e1182373ce22" name="aab89dc811213d349a842e1182373ce22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab89dc811213d349a842e1182373ce22">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a></td>          <td class="paramname"><span class="paramname"><em>__position</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove element at given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator pointing to element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Doc Me! (Iterator pointing to new element at old location?)</dd></dl>
<p>This function will erase the element at the given position and thus shorten the vector by one.</p>
<p>Note This operation could be expensive and if it is frequently used the user should consider using <a class="el" href="classstd_1_1list.html">std::list</a>. The user is also cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibilty. </p>

</div>
</div>
<a id="a6430e8ffbe3e8305d90c25e1eb51e97e" name="a6430e8ffbe3e8305d90c25e1eb51e97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6430e8ffbe3e8305d90c25e1eb51e97e">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reference to the data at the first element of the vector. </p>

</div>
</div>
<a id="ad2c557ad0fef2e563c3796f3b5f41c8b" name="ad2c557ad0fef2e563c3796f3b5f41c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c557ad0fef2e563c3796f3b5f41c8b">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reference to the data at the first element of the vector. </p>

</div>
</div>
<a id="a4a469d526e8025d78d810108834203a8" name="a4a469d526e8025d78d810108834203a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a469d526e8025d78d810108834203a8">&#9670;&#160;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a></td>          <td class="paramname"><span class="paramname"><em>__pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>__n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a number of copies of given data into the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>An iterator that points to the element where data should be inserted. </td></tr>
    <tr><td class="paramname">n</td><td>Amount of elements to be inserted. </td></tr>
    <tr><td class="paramname">x</td><td>Data to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will insert a specified number of copies of the given data into the specified location.</p>
<p>Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using <a class="el" href="classstd_1_1list.html">std::list</a>. </p>

</div>
</div>
<a id="afa978f9e360903868118715e1b6ad07d" name="afa978f9e360903868118715e1b6ad07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa978f9e360903868118715e1b6ad07d">&#9670;&#160;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a></td>          <td class="paramname"><span class="paramname"><em>__position</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an empty element into the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>An iterator that points to the element where empty element should be inserted. </td></tr>
    <tr><td class="paramname">x</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted element.</dd></dl>
<p>This function will insert an empty element into the specified location. Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using <a class="el" href="classstd_1_1list.html">std::list</a>. </p>

</div>
</div>
<a id="a42d8e24145553bdcd4a76f08bfd145ca" name="a42d8e24145553bdcd4a76f08bfd145ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d8e24145553bdcd4a76f08bfd145ca">&#9670;&#160;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a> <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1____normal__iterator.html">iterator</a></td>          <td class="paramname"><span class="paramname"><em>__position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts given value into vector at specified element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>An iterator that points to the element where data should be inserted. </td></tr>
    <tr><td class="paramname">x</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert the given value into the specified location. Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using <a class="el" href="classstd_1_1list.html">std::list</a>. </p>

</div>
</div>
<a id="a4030be0c7bf6bc47457ae59e758c576d" name="a4030be0c7bf6bc47457ae59e758c576d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4030be0c7bf6bc47457ae59e758c576d">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the largest possible vector. <br  />
 </p>

</div>
</div>
<a id="a475f606b188e2096932501e97d20ec80" name="a475f606b188e2096932501e97d20ec80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475f606b188e2096932501e97d20ec80">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>__n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript access to the data contained in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. (For checked lookups see <a class="el" href="#a11362894b61f87331541b5268d0cb033" title="Provides access to the data contained in the vector.">at()</a>.) </p>

</div>
</div>
<a id="aa9e945b9ac9998f33fdcfccf14ba1320" name="aa9e945b9ac9998f33fdcfccf14ba1320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e945b9ac9998f33fdcfccf14ba1320">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>__n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript access to the data contained in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. (For checked lookups see <a class="el" href="#a11362894b61f87331541b5268d0cb033" title="Provides access to the data contained in the vector.">at()</a>.) </p>

</div>
</div>
<a id="a74b162cd471d2baa7ad393c3cd416a59" name="a74b162cd471d2baa7ad393c3cd416a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b162cd471d2baa7ad393c3cd416a59">&#9670;&#160;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes last element from vector. </p>
<p>This is a typical stack operation. It allows us to shrink the vector by one.</p>
<p>Note that no data is returned and if last element's data is needed it should be retrieved before <a class="el" href="#a74b162cd471d2baa7ad393c3cd416a59" title="Removes last element from vector.">pop_back()</a> is called. </p>

</div>
</div>
<a id="a45a86f94f795fab625061f1d6d0ef2c8" name="a45a86f94f795fab625061f1d6d0ef2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a86f94f795fab625061f1d6d0ef2c8">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the end of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Data to be added.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a typical stack operation. The function creates an element at the end of the vector and assigns the given data to it. Due to the nature of a vector this operation can be done in constant time if the vector has preallocated space available. </p>

</div>
</div>
<a id="ae317a81cb77cdb08432c3a8c00b31df4" name="ae317a81cb77cdb08432c3a8c00b31df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae317a81cb77cdb08432c3a8c00b31df4">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reverse iterator that points to the last element in the vector. Iteration is done in reverse element order. </p>

</div>
</div>
<a id="ab9f0ba5fd966dcd150343a6ec55da1d0" name="ab9f0ba5fd966dcd150343a6ec55da1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f0ba5fd966dcd150343a6ec55da1d0">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to the last element in the vector. Iteration is done in reverse element order. </p>

</div>
</div>
<a id="aa8471fb4e9eb65ad51ae65a9f06d1570" name="aa8471fb4e9eb65ad51ae65a9f06d1570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8471fb4e9eb65ad51ae65a9f06d1570">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reverse iterator that points to one before the first element in the vector. Iteration is done in reverse element order. </p>

</div>
</div>
<a id="ad839ae74c295109ecdd0a90990427f67" name="ad839ae74c295109ecdd0a90990427f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad839ae74c295109ecdd0a90990427f67">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to one before the first element in the vector. Iteration is done in reverse element order. </p>

</div>
</div>
<a id="a82ca6994d3b87acac548a110af75fe17" name="a82ca6994d3b87acac548a110af75fe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ca6994d3b87acac548a110af75fe17">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>__n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to preallocate enough memory for specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements required</td></tr>
  </table>
  </dd>
</dl>
<p>This function attempts to reserve enough memory for the vector to hold the specified number of elements. If the number requested is more than <a class="el" href="#a4030be0c7bf6bc47457ae59e758c576d">max_size()</a> length_error is thrown.</p>
<p>The advantage of this function is that if optimal code is a necessity and the user can determine the number of elements that will be required the user can reserve the memory and thus prevent a possible reallocation of memory and copy of vector data. </p>

</div>
</div>
<a id="a1134bcc83ff6c70cf78bab3cd426feaf" name="a1134bcc83ff6c70cf78bab3cd426feaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1134bcc83ff6c70cf78bab3cd426feaf">&#9670;&#160;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>__new_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the vector to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>Number of elements the vector should contain.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will resize the vector to the specified number of elements. If the number is smaller than the vector's current size the vector is truncated, otherwise the vector is extended and new elements are left uninitialized. </p>

</div>
</div>
<a id="aa3bbf523308970c5c2faf07c457ff488" name="aa3bbf523308970c5c2faf07c457ff488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bbf523308970c5c2faf07c457ff488">&#9670;&#160;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>__new_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the vector to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>Number of elements the vector should contain. </td></tr>
    <tr><td class="paramname">x</td><td>Data with which new elements should be populated.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will resize the vector to the specified number of elements. If the number is smaller than the vector's current size the vector is truncated, otherwise the vector is extended and new elements are populated with given data. </p>

</div>
</div>
<a id="a74807a76d4c153b95760ed24eaa33fe5" name="a74807a76d4c153b95760ed24eaa33fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74807a76d4c153b95760ed24eaa33fe5">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Tp , class _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; _Tp, _Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the vector. <br  />
 </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ts2/opm53/tools/sce/ee/gcc/include/g++-v3/bits/<a class="el" href="localefwd_8h_source.html">localefwd.h</a></li>
<li>ts2/opm53/tools/sce/ee/gcc/include/g++-v3/bits/<a class="el" href="stl__vector_8h_source.html">stl_vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
