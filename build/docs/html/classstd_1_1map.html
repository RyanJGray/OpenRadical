<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenRadical: std::map&lt; _Key, _Tp, _Compare, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenRadical
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>std</b></li><li class="navelem"><a class="el" href="classstd_1_1map.html">map</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A standard container made up of pairs (see <a class="el" href="structstd_1_1pair.html" title="pair holds two objects of arbitrary type.">std::pair</a> in &lt;utility&gt;) which can be retrieved based on a key.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stl__map_8h_source.html">stl_map.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1map_1_1value__compare.html">value_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae10195cd84404a388ead9b48e2c2d235" id="r_ae10195cd84404a388ead9b48e2c2d235"><td class="memItemLeft" align="right" valign="top"><a id="ae10195cd84404a388ead9b48e2c2d235" name="ae10195cd84404a388ead9b48e2c2d235"></a>
typedef _Key&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr class="separator:ae10195cd84404a388ead9b48e2c2d235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c9a109cb273056004ed69a4f226df9" id="r_ab6c9a109cb273056004ed69a4f226df9"><td class="memItemLeft" align="right" valign="top"><a id="ab6c9a109cb273056004ed69a4f226df9" name="ab6c9a109cb273056004ed69a4f226df9"></a>
typedef _Tp&#160;</td><td class="memItemRight" valign="bottom"><b>data_type</b></td></tr>
<tr class="separator:ab6c9a109cb273056004ed69a4f226df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6d8e74d5b54034a3e5e3e6d2a88079" id="r_a2f6d8e74d5b54034a3e5e3e6d2a88079"><td class="memItemLeft" align="right" valign="top"><a id="a2f6d8e74d5b54034a3e5e3e6d2a88079" name="a2f6d8e74d5b54034a3e5e3e6d2a88079"></a>
typedef _Tp&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b></td></tr>
<tr class="separator:a2f6d8e74d5b54034a3e5e3e6d2a88079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422746f4c18a71e5188ce6452fc98934" id="r_a422746f4c18a71e5188ce6452fc98934"><td class="memItemLeft" align="right" valign="top"><a id="a422746f4c18a71e5188ce6452fc98934" name="a422746f4c18a71e5188ce6452fc98934"></a>
typedef <a class="el" href="structstd_1_1pair.html">pair</a>&lt; const _Key, _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a422746f4c18a71e5188ce6452fc98934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9b1e241538a0fabefa11e65bc41a11" id="r_a1a9b1e241538a0fabefa11e65bc41a11"><td class="memItemLeft" align="right" valign="top"><a id="a1a9b1e241538a0fabefa11e65bc41a11" name="a1a9b1e241538a0fabefa11e65bc41a11"></a>
typedef _Compare&#160;</td><td class="memItemRight" valign="bottom"><b>key_compare</b></td></tr>
<tr class="separator:a1a9b1e241538a0fabefa11e65bc41a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c21c83ac29df9a606f563ec7c0a2e87" id="r_a3c21c83ac29df9a606f563ec7c0a2e87"><td class="memItemLeft" align="right" valign="top"><a id="a3c21c83ac29df9a606f563ec7c0a2e87" name="a3c21c83ac29df9a606f563ec7c0a2e87"></a>
typedef _Rep_type::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a3c21c83ac29df9a606f563ec7c0a2e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9821f60e4a49c8ce5d681c29e1082c" id="r_afd9821f60e4a49c8ce5d681c29e1082c"><td class="memItemLeft" align="right" valign="top"><a id="afd9821f60e4a49c8ce5d681c29e1082c" name="afd9821f60e4a49c8ce5d681c29e1082c"></a>
typedef _Rep_type::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:afd9821f60e4a49c8ce5d681c29e1082c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d7f0f368ef662d4213733d978173be" id="r_a27d7f0f368ef662d4213733d978173be"><td class="memItemLeft" align="right" valign="top"><a id="a27d7f0f368ef662d4213733d978173be" name="a27d7f0f368ef662d4213733d978173be"></a>
typedef _Rep_type::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a27d7f0f368ef662d4213733d978173be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020870cd806785b0d1d913f2d07a17c6" id="r_a020870cd806785b0d1d913f2d07a17c6"><td class="memItemLeft" align="right" valign="top"><a id="a020870cd806785b0d1d913f2d07a17c6" name="a020870cd806785b0d1d913f2d07a17c6"></a>
typedef _Rep_type::const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a020870cd806785b0d1d913f2d07a17c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa9be4d3b8049458f5d9c6078f6705d" id="r_abaa9be4d3b8049458f5d9c6078f6705d"><td class="memItemLeft" align="right" valign="top"><a id="abaa9be4d3b8049458f5d9c6078f6705d" name="abaa9be4d3b8049458f5d9c6078f6705d"></a>
typedef <a class="el" href="structstd_1_1__Rb__tree__iterator.html">_Rep_type::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:abaa9be4d3b8049458f5d9c6078f6705d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3897b5d1cf6d46c2dcab61dbed608eed" id="r_a3897b5d1cf6d46c2dcab61dbed608eed"><td class="memItemLeft" align="right" valign="top"><a id="a3897b5d1cf6d46c2dcab61dbed608eed" name="a3897b5d1cf6d46c2dcab61dbed608eed"></a>
typedef <a class="el" href="structstd_1_1__Rb__tree__iterator.html">_Rep_type::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a3897b5d1cf6d46c2dcab61dbed608eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745da041791514192a17ca17eec02f14" id="r_a745da041791514192a17ca17eec02f14"><td class="memItemLeft" align="right" valign="top"><a id="a745da041791514192a17ca17eec02f14" name="a745da041791514192a17ca17eec02f14"></a>
typedef _Rep_type::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a745da041791514192a17ca17eec02f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf45cca8291f9ceaf041a38dd3e8e1d9" id="r_adf45cca8291f9ceaf041a38dd3e8e1d9"><td class="memItemLeft" align="right" valign="top"><a id="adf45cca8291f9ceaf041a38dd3e8e1d9" name="adf45cca8291f9ceaf041a38dd3e8e1d9"></a>
typedef _Rep_type::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:adf45cca8291f9ceaf041a38dd3e8e1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1d6375c7d80a616a6ca120da8a4a5f" id="r_a4a1d6375c7d80a616a6ca120da8a4a5f"><td class="memItemLeft" align="right" valign="top"><a id="a4a1d6375c7d80a616a6ca120da8a4a5f" name="a4a1d6375c7d80a616a6ca120da8a4a5f"></a>
typedef _Rep_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a4a1d6375c7d80a616a6ca120da8a4a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9eeca4567d10ca6c9698f138f382a4" id="r_abc9eeca4567d10ca6c9698f138f382a4"><td class="memItemLeft" align="right" valign="top"><a id="abc9eeca4567d10ca6c9698f138f382a4" name="abc9eeca4567d10ca6c9698f138f382a4"></a>
typedef _Rep_type::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:abc9eeca4567d10ca6c9698f138f382a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6abd0707360f2e8fc90cf74b60165e2" id="r_ab6abd0707360f2e8fc90cf74b60165e2"><td class="memItemLeft" align="right" valign="top"><a id="ab6abd0707360f2e8fc90cf74b60165e2" name="ab6abd0707360f2e8fc90cf74b60165e2"></a>
typedef _Rep_type::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:ab6abd0707360f2e8fc90cf74b60165e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa12fa7df574ac42da454cba7581c258e" id="r_aa12fa7df574ac42da454cba7581c258e"><td class="memItemLeft" align="right" valign="top"><a id="aa12fa7df574ac42da454cba7581c258e" name="aa12fa7df574ac42da454cba7581c258e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>map</b> (const _Compare &amp;__comp, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:aa12fa7df574ac42da454cba7581c258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6339535802f1937f3dd78ee04d950ea7" id="r_a6339535802f1937f3dd78ee04d950ea7"><td class="memTemplParams" colspan="2"><a id="a6339535802f1937f3dd78ee04d950ea7" name="a6339535802f1937f3dd78ee04d950ea7"></a>
template&lt;class _InputIterator &gt; </td></tr>
<tr class="memitem:a6339535802f1937f3dd78ee04d950ea7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (_InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:a6339535802f1937f3dd78ee04d950ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30882bd54277810ace3d0630cbc3252" id="r_ac30882bd54277810ace3d0630cbc3252"><td class="memTemplParams" colspan="2"><a id="ac30882bd54277810ace3d0630cbc3252" name="ac30882bd54277810ace3d0630cbc3252"></a>
template&lt;class _InputIterator &gt; </td></tr>
<tr class="memitem:ac30882bd54277810ace3d0630cbc3252"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (_InputIterator __first, _InputIterator __last, const _Compare &amp;__comp, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:ac30882bd54277810ace3d0630cbc3252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf650c9e9b394efe61d56df8d6bce426" id="r_aaf650c9e9b394efe61d56df8d6bce426"><td class="memItemLeft" align="right" valign="top"><a id="aaf650c9e9b394efe61d56df8d6bce426" name="aaf650c9e9b394efe61d56df8d6bce426"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>map</b> (const <a class="el" href="classstd_1_1map.html">map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__x)</td></tr>
<tr class="separator:aaf650c9e9b394efe61d56df8d6bce426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9012480e617293012cace7bad9994d6" id="r_ad9012480e617293012cace7bad9994d6"><td class="memItemLeft" align="right" valign="top"><a id="ad9012480e617293012cace7bad9994d6" name="ad9012480e617293012cace7bad9994d6"></a>
<a class="el" href="classstd_1_1map.html">map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstd_1_1map.html">map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__x)</td></tr>
<tr class="separator:ad9012480e617293012cace7bad9994d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59af09cf176afb26d8e2657581429d3f" id="r_a59af09cf176afb26d8e2657581429d3f"><td class="memItemLeft" align="right" valign="top"><a id="a59af09cf176afb26d8e2657581429d3f" name="a59af09cf176afb26d8e2657581429d3f"></a>
key_compare&#160;</td><td class="memItemRight" valign="bottom"><b>key_comp</b> () const</td></tr>
<tr class="separator:a59af09cf176afb26d8e2657581429d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c51f439c6328b72ebdd7e5e558ef847" id="r_a2c51f439c6328b72ebdd7e5e558ef847"><td class="memItemLeft" align="right" valign="top"><a id="a2c51f439c6328b72ebdd7e5e558ef847" name="a2c51f439c6328b72ebdd7e5e558ef847"></a>
<a class="el" href="classstd_1_1map_1_1value__compare.html">value_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><b>value_comp</b> () const</td></tr>
<tr class="separator:a2c51f439c6328b72ebdd7e5e558ef847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425ebc2e8dfd25065ed023a0eb0c5e33" id="r_a425ebc2e8dfd25065ed023a0eb0c5e33"><td class="memItemLeft" align="right" valign="top"><a id="a425ebc2e8dfd25065ed023a0eb0c5e33" name="a425ebc2e8dfd25065ed023a0eb0c5e33"></a>
allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const</td></tr>
<tr class="separator:a425ebc2e8dfd25065ed023a0eb0c5e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779d256efbf86c57b2c530a9e3bf42ff" id="r_a779d256efbf86c57b2c530a9e3bf42ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a779d256efbf86c57b2c530a9e3bf42ff">begin</a> ()</td></tr>
<tr class="separator:a779d256efbf86c57b2c530a9e3bf42ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af6a4a0198bdb0fdbe80e29fb2772a7" id="r_a4af6a4a0198bdb0fdbe80e29fb2772a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4af6a4a0198bdb0fdbe80e29fb2772a7">begin</a> () const</td></tr>
<tr class="separator:a4af6a4a0198bdb0fdbe80e29fb2772a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166bacc060a4cd5b58c9ef00e5765c6a" id="r_a166bacc060a4cd5b58c9ef00e5765c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a166bacc060a4cd5b58c9ef00e5765c6a">end</a> ()</td></tr>
<tr class="separator:a166bacc060a4cd5b58c9ef00e5765c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242965c3f3f02c22ee0dbbce170c6b6e" id="r_a242965c3f3f02c22ee0dbbce170c6b6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a242965c3f3f02c22ee0dbbce170c6b6e">end</a> () const</td></tr>
<tr class="separator:a242965c3f3f02c22ee0dbbce170c6b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d71594b6b34172aca695a8a993a539" id="r_a17d71594b6b34172aca695a8a993a539"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17d71594b6b34172aca695a8a993a539">rbegin</a> ()</td></tr>
<tr class="separator:a17d71594b6b34172aca695a8a993a539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c39ff9bab570360f98c07b0d7165a76" id="r_a4c39ff9bab570360f98c07b0d7165a76"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c39ff9bab570360f98c07b0d7165a76">rbegin</a> () const</td></tr>
<tr class="separator:a4c39ff9bab570360f98c07b0d7165a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f3ece6abf4a393d5fc525b6955e048" id="r_a72f3ece6abf4a393d5fc525b6955e048"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72f3ece6abf4a393d5fc525b6955e048">rend</a> ()</td></tr>
<tr class="separator:a72f3ece6abf4a393d5fc525b6955e048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b5c9e1e868438cc00fc63327296cea" id="r_a66b5c9e1e868438cc00fc63327296cea"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66b5c9e1e868438cc00fc63327296cea">rend</a> () const</td></tr>
<tr class="separator:a66b5c9e1e868438cc00fc63327296cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab99f3968dc2f5e5a50d1e472600c84" id="r_a4ab99f3968dc2f5e5a50d1e472600c84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ab99f3968dc2f5e5a50d1e472600c84">empty</a> () const</td></tr>
<tr class="separator:a4ab99f3968dc2f5e5a50d1e472600c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f6dc8a8ad8d81d57ee382ba6dc0d98" id="r_af2f6dc8a8ad8d81d57ee382ba6dc0d98"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2f6dc8a8ad8d81d57ee382ba6dc0d98">size</a> () const</td></tr>
<tr class="separator:af2f6dc8a8ad8d81d57ee382ba6dc0d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ac1b6137876c3d61e611a661094382" id="r_ab2ac1b6137876c3d61e611a661094382"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2ac1b6137876c3d61e611a661094382">max_size</a> () const</td></tr>
<tr class="separator:ab2ac1b6137876c3d61e611a661094382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40741cf2a013ef3cda7133390cdbd2ea" id="r_a40741cf2a013ef3cda7133390cdbd2ea"><td class="memItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40741cf2a013ef3cda7133390cdbd2ea">operator[]</a> (const key_type &amp;__k)</td></tr>
<tr class="memdesc:a40741cf2a013ef3cda7133390cdbd2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript ( [] ) access to map data.  <br /></td></tr>
<tr class="separator:a40741cf2a013ef3cda7133390cdbd2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d6779c315b387b5064b62a8af446d7" id="r_a73d6779c315b387b5064b62a8af446d7"><td class="memItemLeft" align="right" valign="top"><a id="a73d6779c315b387b5064b62a8af446d7" name="a73d6779c315b387b5064b62a8af446d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classstd_1_1map.html">map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__x)</td></tr>
<tr class="separator:a73d6779c315b387b5064b62a8af446d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1483510463de8bfa2e2058063f6c53" id="r_a4b1483510463de8bfa2e2058063f6c53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1pair.html">pair</a>&lt; <a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b1483510463de8bfa2e2058063f6c53">insert</a> (const <a class="el" href="structstd_1_1pair.html">value_type</a> &amp;__x)</td></tr>
<tr class="memdesc:a4b1483510463de8bfa2e2058063f6c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert a <a class="el" href="structstd_1_1pair.html" title="pair holds two objects of arbitrary type.">std::pair</a> into the map.  <br /></td></tr>
<tr class="separator:a4b1483510463de8bfa2e2058063f6c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d43a084fe801f6612f7e5d296772ca" id="r_a04d43a084fe801f6612f7e5d296772ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04d43a084fe801f6612f7e5d296772ca">insert</a> (<a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a> position, const <a class="el" href="structstd_1_1pair.html">value_type</a> &amp;__x)</td></tr>
<tr class="memdesc:a04d43a084fe801f6612f7e5d296772ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert a <a class="el" href="structstd_1_1pair.html" title="pair holds two objects of arbitrary type.">std::pair</a> into the map.  <br /></td></tr>
<tr class="separator:a04d43a084fe801f6612f7e5d296772ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3186e7576e4ffc474fd92f66e460d231" id="r_a3186e7576e4ffc474fd92f66e460d231"><td class="memTemplParams" colspan="2">template&lt;class _InputIterator &gt; </td></tr>
<tr class="memitem:a3186e7576e4ffc474fd92f66e460d231"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3186e7576e4ffc474fd92f66e460d231">insert</a> (_InputIterator __first, _InputIterator __last)</td></tr>
<tr class="memdesc:a3186e7576e4ffc474fd92f66e460d231"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template function that attemps to insert elements from another range (possibly another map).  <br /></td></tr>
<tr class="separator:a3186e7576e4ffc474fd92f66e460d231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e68bc8f57dee2f0fca4624d18c1d13" id="r_a11e68bc8f57dee2f0fca4624d18c1d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11e68bc8f57dee2f0fca4624d18c1d13">erase</a> (<a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a> __position)</td></tr>
<tr class="memdesc:a11e68bc8f57dee2f0fca4624d18c1d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an element from a map.  <br /></td></tr>
<tr class="separator:a11e68bc8f57dee2f0fca4624d18c1d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b510fc380b070d899d73a278cbb8faf" id="r_a6b510fc380b070d899d73a278cbb8faf"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b510fc380b070d899d73a278cbb8faf">erase</a> (const key_type &amp;__x)</td></tr>
<tr class="memdesc:a6b510fc380b070d899d73a278cbb8faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an element according to the provided key.  <br /></td></tr>
<tr class="separator:a6b510fc380b070d899d73a278cbb8faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9f32857d1b4bc2fde80e3f0545b5c0" id="r_a3f9f32857d1b4bc2fde80e3f0545b5c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f9f32857d1b4bc2fde80e3f0545b5c0">erase</a> (<a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a> __first, <a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a> __last)</td></tr>
<tr class="memdesc:a3f9f32857d1b4bc2fde80e3f0545b5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a [first,last) range of elements from a map.  <br /></td></tr>
<tr class="separator:a3f9f32857d1b4bc2fde80e3f0545b5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8e6b6c3d4981f65ea351244d47f227" id="r_a7d8e6b6c3d4981f65ea351244d47f227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d8e6b6c3d4981f65ea351244d47f227">clear</a> ()</td></tr>
<tr class="separator:a7d8e6b6c3d4981f65ea351244d47f227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcd985632d8ad7ddba069aa776e2dfe" id="r_abdcd985632d8ad7ddba069aa776e2dfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdcd985632d8ad7ddba069aa776e2dfe">find</a> (const key_type &amp;__x)</td></tr>
<tr class="memdesc:abdcd985632d8ad7ddba069aa776e2dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to locate an element in a map.  <br /></td></tr>
<tr class="separator:abdcd985632d8ad7ddba069aa776e2dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cdb0ebaf753ec1244849dbff2ec4cf" id="r_a07cdb0ebaf753ec1244849dbff2ec4cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07cdb0ebaf753ec1244849dbff2ec4cf">find</a> (const key_type &amp;__x) const</td></tr>
<tr class="memdesc:a07cdb0ebaf753ec1244849dbff2ec4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to locate an element in a map.  <br /></td></tr>
<tr class="separator:a07cdb0ebaf753ec1244849dbff2ec4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44da6d0dc51d80a873cc9405a805c712" id="r_a44da6d0dc51d80a873cc9405a805c712"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44da6d0dc51d80a873cc9405a805c712">count</a> (const key_type &amp;__x) const</td></tr>
<tr class="memdesc:a44da6d0dc51d80a873cc9405a805c712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the number of elements with given key.  <br /></td></tr>
<tr class="separator:a44da6d0dc51d80a873cc9405a805c712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb7e90f8d6bece7f9ffb6b76c9ab081" id="r_adbb7e90f8d6bece7f9ffb6b76c9ab081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbb7e90f8d6bece7f9ffb6b76c9ab081">lower_bound</a> (const key_type &amp;__x)</td></tr>
<tr class="memdesc:adbb7e90f8d6bece7f9ffb6b76c9ab081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the beginning of a subsequence matching given key.  <br /></td></tr>
<tr class="separator:adbb7e90f8d6bece7f9ffb6b76c9ab081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab801bf5b252cc1b28af052263ce33d7a" id="r_ab801bf5b252cc1b28af052263ce33d7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab801bf5b252cc1b28af052263ce33d7a">lower_bound</a> (const key_type &amp;__x) const</td></tr>
<tr class="memdesc:ab801bf5b252cc1b28af052263ce33d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the beginning of a subsequence matching given key.  <br /></td></tr>
<tr class="separator:ab801bf5b252cc1b28af052263ce33d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f6ba9ed7f80198dd444d6d830a3c80" id="r_a31f6ba9ed7f80198dd444d6d830a3c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31f6ba9ed7f80198dd444d6d830a3c80">upper_bound</a> (const key_type &amp;__x)</td></tr>
<tr class="memdesc:a31f6ba9ed7f80198dd444d6d830a3c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the end of a subsequence matching given key.  <br /></td></tr>
<tr class="separator:a31f6ba9ed7f80198dd444d6d830a3c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9ba5f5b31a79317b1c5ec547b9ec6c" id="r_afd9ba5f5b31a79317b1c5ec547b9ec6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd9ba5f5b31a79317b1c5ec547b9ec6c">upper_bound</a> (const key_type &amp;__x) const</td></tr>
<tr class="memdesc:afd9ba5f5b31a79317b1c5ec547b9ec6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the end of a subsequence matching given key.  <br /></td></tr>
<tr class="separator:afd9ba5f5b31a79317b1c5ec547b9ec6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c53343e56dcfcbf4bd4902c3883c685" id="r_a5c53343e56dcfcbf4bd4902c3883c685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1pair.html">pair</a>&lt; <a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a>, <a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c53343e56dcfcbf4bd4902c3883c685">equal_range</a> (const key_type &amp;__x)</td></tr>
<tr class="memdesc:a5c53343e56dcfcbf4bd4902c3883c685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a subsequence matching given key.  <br /></td></tr>
<tr class="separator:a5c53343e56dcfcbf4bd4902c3883c685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c527e87885334b389b7a3168ce45e9" id="r_a00c527e87885334b389b7a3168ce45e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1pair.html">pair</a>&lt; <a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a>, <a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00c527e87885334b389b7a3168ce45e9">equal_range</a> (const key_type &amp;__x) const</td></tr>
<tr class="memdesc:a00c527e87885334b389b7a3168ce45e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a subsequence matching given key.  <br /></td></tr>
<tr class="separator:a00c527e87885334b389b7a3168ce45e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a05f842d5d0a0a84e01fcc406ca18ce72" id="r_a05f842d5d0a0a84e01fcc406ca18ce72"><td class="memTemplParams" colspan="2"><a id="a05f842d5d0a0a84e01fcc406ca18ce72" name="a05f842d5d0a0a84e01fcc406ca18ce72"></a>
template&lt;class _K1 , class _T1 , class _C1 , class _A1 &gt; </td></tr>
<tr class="memitem:a05f842d5d0a0a84e01fcc406ca18ce72"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classstd_1_1map.html">map</a>&lt; _K1, _T1, _C1, _A1 &gt; &amp;, const <a class="el" href="classstd_1_1map.html">map</a>&lt; _K1, _T1, _C1, _A1 &gt; &amp;)</td></tr>
<tr class="separator:a05f842d5d0a0a84e01fcc406ca18ce72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00451026c0ad74c0de0c2118f23964ba" id="r_a00451026c0ad74c0de0c2118f23964ba"><td class="memTemplParams" colspan="2"><a id="a00451026c0ad74c0de0c2118f23964ba" name="a00451026c0ad74c0de0c2118f23964ba"></a>
template&lt;class _K1 , class _T1 , class _C1 , class _A1 &gt; </td></tr>
<tr class="memitem:a00451026c0ad74c0de0c2118f23964ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classstd_1_1map.html">map</a>&lt; _K1, _T1, _C1, _A1 &gt; &amp;, const <a class="el" href="classstd_1_1map.html">map</a>&lt; _K1, _T1, _C1, _A1 &gt; &amp;)</td></tr>
<tr class="separator:a00451026c0ad74c0de0c2118f23964ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class _Key, class _Tp, class _Compare = less&lt;_Key&gt;, class _Alloc = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt;<br />
class std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;</div><p>A standard container made up of pairs (see <a class="el" href="structstd_1_1pair.html" title="pair holds two objects of arbitrary type.">std::pair</a> in &lt;utility&gt;) which can be retrieved based on a key. </p>
<p>This is an associative container. Values contained within it can be quickly retrieved through a key element. Example: MyMap["First"] would return the data associated with the key "First". </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a779d256efbf86c57b2c530a9e3bf42ff" name="a779d256efbf86c57b2c530a9e3bf42ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779d256efbf86c57b2c530a9e3bf42ff">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a> <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points to the first pair in the map. Iteration is done in ascending order according to the keys. </p>

</div>
</div>
<a id="a4af6a4a0198bdb0fdbe80e29fb2772a7" name="a4af6a4a0198bdb0fdbe80e29fb2772a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af6a4a0198bdb0fdbe80e29fb2772a7">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a> <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first pair in the map. Iteration is done in ascending order according to the keys. </p>

</div>
</div>
<a id="a7d8e6b6c3d4981f65ea351244d47f227" name="a7d8e6b6c3d4981f65ea351244d47f227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8e6b6c3d4981f65ea351244d47f227">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all elements in a map. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibilty. </p>

</div>
</div>
<a id="a44da6d0dc51d80a873cc9405a805c712" name="a44da6d0dc51d80a873cc9405a805c712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44da6d0dc51d80a873cc9405a805c712">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of elements with given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Key of (key, value) pairs to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with specified key.</dd></dl>
<p>This function only makes sense for multimaps. </p>

</div>
</div>
<a id="a4ab99f3968dc2f5e5a50d1e472600c84" name="a4ab99f3968dc2f5e5a50d1e472600c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab99f3968dc2f5e5a50d1e472600c84">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the map is empty. (Thus <a class="el" href="#a779d256efbf86c57b2c530a9e3bf42ff">begin()</a> would equal <a class="el" href="#a166bacc060a4cd5b58c9ef00e5765c6a">end()</a>.) <br  />
 </p>

</div>
</div>
<a id="a166bacc060a4cd5b58c9ef00e5765c6a" name="a166bacc060a4cd5b58c9ef00e5765c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166bacc060a4cd5b58c9ef00e5765c6a">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a> <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points one past the last pair in the map. Iteration is done in ascending order according to the keys. </p>

</div>
</div>
<a id="a242965c3f3f02c22ee0dbbce170c6b6e" name="a242965c3f3f02c22ee0dbbce170c6b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242965c3f3f02c22ee0dbbce170c6b6e">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a> <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last pair in the map. Iteration is done in ascending order according to the keys. </p>

</div>
</div>
<a id="a5c53343e56dcfcbf4bd4902c3883c685" name="a5c53343e56dcfcbf4bd4902c3883c685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c53343e56dcfcbf4bd4902c3883c685">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1pair.html">pair</a>&lt; <a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a>, <a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a> &gt; <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Key of (key, value) pairs to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function improves on <a class="el" href="#adbb7e90f8d6bece7f9ffb6b76c9ab081" title="Finds the beginning of a subsequence matching given key.">lower_bound()</a> and <a class="el" href="#a31f6ba9ed7f80198dd444d6d830a3c80" title="Finds the end of a subsequence matching given key.">upper_bound()</a> by giving a more elegant and efficient solution. It returns a pair of which the first element possibly points to the first element matching the given key and the second element possibly points to the last element matching the given key. If unsuccessful the first element of the returned pair will contain an iterator pointing to the next greatest element or, if no such greater element exists, to <a class="el" href="#a166bacc060a4cd5b58c9ef00e5765c6a">end()</a>.</p>
<p>This function only makes sense for multimaps. </p>

</div>
</div>
<a id="a00c527e87885334b389b7a3168ce45e9" name="a00c527e87885334b389b7a3168ce45e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c527e87885334b389b7a3168ce45e9">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1pair.html">pair</a>&lt; <a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a>, <a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a> &gt; <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Key of (key, value) pairs to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of read-only (constant) iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function improves on <a class="el" href="#adbb7e90f8d6bece7f9ffb6b76c9ab081" title="Finds the beginning of a subsequence matching given key.">lower_bound()</a> and <a class="el" href="#a31f6ba9ed7f80198dd444d6d830a3c80" title="Finds the end of a subsequence matching given key.">upper_bound()</a> by giving a more elegant and efficient solution. It returns a pair of which the first element possibly points to the first element matching the given key and the second element possibly points to the last element matching the given key. If unsuccessful the first element of the returned pair will contain an iterator pointing to the next greatest element or, if no such a greater element exists, to <a class="el" href="#a166bacc060a4cd5b58c9ef00e5765c6a">end()</a>.</p>
<p>This function only makes sense for multimaps. </p>

</div>
</div>
<a id="a6b510fc380b070d899d73a278cbb8faf" name="a6b510fc380b070d899d73a278cbb8faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b510fc380b070d899d73a278cbb8faf">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an element according to the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Key of element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Doc me! (Number of elements that match key? Only makes sense with multimap)</dd></dl>
<p>This function erases an element, located by the given key, from a map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibilty. </p>

</div>
</div>
<a id="a3f9f32857d1b4bc2fde80e3f0545b5c0" name="a3f9f32857d1b4bc2fde80e3f0545b5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9f32857d1b4bc2fde80e3f0545b5c0">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a></td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a></td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases a [first,last) range of elements from a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the start of the range to be erased. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the end of the range to be erased.</td></tr>
  </table>
  </dd>
</dl>
<p>This function erases a sequence of elements from a map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibilty. </p>

</div>
</div>
<a id="a11e68bc8f57dee2f0fca4624d18c1d13" name="a11e68bc8f57dee2f0fca4624d18c1d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e68bc8f57dee2f0fca4624d18c1d13">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a></td>          <td class="paramname"><span class="paramname"><em>__position</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an element from a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>An iterator pointing to the element to be erased.</td></tr>
  </table>
  </dd>
</dl>
<p>This function erases an element, pointed to by the given iterator, from a map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibilty. </p>

</div>
</div>
<a id="abdcd985632d8ad7ddba069aa776e2dfe" name="abdcd985632d8ad7ddba069aa776e2dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcd985632d8ad7ddba069aa776e2dfe">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a> <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or <a class="el" href="#a166bacc060a4cd5b58c9ef00e5765c6a">end()</a> if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after pair. If unsuccessful it returns the one past the end ( <a class="el" href="#a166bacc060a4cd5b58c9ef00e5765c6a">end()</a> ) iterator. </p>

</div>
</div>
<a id="a07cdb0ebaf753ec1244849dbff2ec4cf" name="a07cdb0ebaf753ec1244849dbff2ec4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cdb0ebaf753ec1244849dbff2ec4cf">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a> <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) iterator pointing to sought-after element, or <a class="el" href="#a166bacc060a4cd5b58c9ef00e5765c6a">end()</a> if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns a constant iterator pointing to the sought after pair. If unsuccessful it returns the one past the end ( <a class="el" href="#a166bacc060a4cd5b58c9ef00e5765c6a">end()</a> ) iterator. </p>

</div>
</div>
<a id="a3186e7576e4ffc474fd92f66e460d231" name="a3186e7576e4ffc474fd92f66e460d231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3186e7576e4ffc474fd92f66e460d231">&#9670;&#160;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class _InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">_InputIterator</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A template function that attemps to insert elements from another range (possibly another map). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the start of the range to be inserted. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b1483510463de8bfa2e2058063f6c53" name="a4b1483510463de8bfa2e2058063f6c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1483510463de8bfa2e2058063f6c53">&#9670;&#160;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1pair.html">pair</a>&lt; <a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a>, bool &gt; <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstd_1_1pair.html">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a <a class="el" href="structstd_1_1pair.html" title="pair holds two objects of arbitrary type.">std::pair</a> into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pair to be inserted (see <a class="el" href="stl__pair_8h.html#adf2faadc5844fd5dc34e20c10329f881" title="A convenience wrapper for creating a pair from two objects.">std::make_pair</a> for easy creation of pairs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of which the first element is an iterator that points to the possibly inserted pair, a second element of type bool to show if the pair was actually inserted.</dd></dl>
<p>This function attempts to insert a (key, value) pair into the map. A map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the map. </p>

</div>
</div>
<a id="a04d43a084fe801f6612f7e5d296772ca" name="a04d43a084fe801f6612f7e5d296772ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d43a084fe801f6612f7e5d296772ca">&#9670;&#160;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a> <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a></td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstd_1_1pair.html">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a <a class="el" href="structstd_1_1pair.html" title="pair holds two objects of arbitrary type.">std::pair</a> into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">x</td><td>Pair to be inserted (see <a class="el" href="stl__pair_8h.html#adf2faadc5844fd5dc34e20c10329f881" title="A convenience wrapper for creating a pair from two objects.">std::make_pair</a> for easy creation of pairs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted (key,value) pair.</dd></dl>
<p>This function is not concerned about whether the insertion took place or not and thus does not return a boolean like the single-argument <a class="el" href="#a4b1483510463de8bfa2e2058063f6c53" title="Attempts to insert a std::pair into the map.">insert()</a> does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency. </p>

</div>
</div>
<a id="adbb7e90f8d6bece7f9ffb6b76c9ab081" name="adbb7e90f8d6bece7f9ffb6b76c9ab081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb7e90f8d6bece7f9ffb6b76c9ab081">&#9670;&#160;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a> <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the beginning of a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to first element matching given key, or <a class="el" href="#a166bacc060a4cd5b58c9ef00e5765c6a">end()</a> if not found.</dd></dl>
<p>This function is useful only with <a class="el" href="classstd_1_1multimap.html" title="A standard container made up of pairs (see std::pair in &lt;utility&gt;) which can be retrieved based on a ...">std::multimap</a>. It returns the first element of a subsequence of elements that matches the given key. If unsuccessful it returns an iterator pointing to the first element that has a greater value than given key or <a class="el" href="#a166bacc060a4cd5b58c9ef00e5765c6a">end()</a> if no such element exists. </p>

</div>
</div>
<a id="ab801bf5b252cc1b28af052263ce33d7a" name="ab801bf5b252cc1b28af052263ce33d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab801bf5b252cc1b28af052263ce33d7a">&#9670;&#160;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a> <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the beginning of a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) iterator pointing to first element matching given key, or <a class="el" href="#a166bacc060a4cd5b58c9ef00e5765c6a">end()</a> if not found.</dd></dl>
<p>This function is useful only with <a class="el" href="classstd_1_1multimap.html" title="A standard container made up of pairs (see std::pair in &lt;utility&gt;) which can be retrieved based on a ...">std::multimap</a>. It returns the first element of a subsequence of elements that matches the given key. If unsuccessful the iterator will point to the next greatest element or, if no such greater element exists, to <a class="el" href="#a166bacc060a4cd5b58c9ef00e5765c6a">end()</a>. </p>

</div>
</div>
<a id="ab2ac1b6137876c3d61e611a661094382" name="ab2ac1b6137876c3d61e611a661094382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ac1b6137876c3d61e611a661094382">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum size of the map. <br  />
 </p>

</div>
</div>
<a id="a40741cf2a013ef3cda7133390cdbd2ea" name="a40741cf2a013ef3cda7133390cdbd2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40741cf2a013ef3cda7133390cdbd2ea">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>__k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript ( [] ) access to map data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key for which data should be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<p>Allows for easy lookup with the subscript ( [] ) operator. Returns the data associated with the key specified in subscript. If the key does not exist a pair with that key is created with a default value, which is then returned. </p>

</div>
</div>
<a id="a17d71594b6b34172aca695a8a993a539" name="a17d71594b6b34172aca695a8a993a539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d71594b6b34172aca695a8a993a539">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reverse iterator that points to the last pair in the map. Iteration is done in descending order according to the keys. </p>

</div>
</div>
<a id="a4c39ff9bab570360f98c07b0d7165a76" name="a4c39ff9bab570360f98c07b0d7165a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c39ff9bab570360f98c07b0d7165a76">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to the last pair in the map. Iteration is done in descending order according to the keys. </p>

</div>
</div>
<a id="a72f3ece6abf4a393d5fc525b6955e048" name="a72f3ece6abf4a393d5fc525b6955e048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f3ece6abf4a393d5fc525b6955e048">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reverse iterator that points to one before the first pair in the map. Iteration is done in descending order according to the keys. </p>

</div>
</div>
<a id="a66b5c9e1e868438cc00fc63327296cea" name="a66b5c9e1e868438cc00fc63327296cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b5c9e1e868438cc00fc63327296cea">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to one before the first pair in the map. Iteration is done in descending order according to the keys. </p>

</div>
</div>
<a id="af2f6dc8a8ad8d81d57ee382ba6dc0d98" name="af2f6dc8a8ad8d81d57ee382ba6dc0d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f6dc8a8ad8d81d57ee382ba6dc0d98">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the map. <br  />
 </p>

</div>
</div>
<a id="a31f6ba9ed7f80198dd444d6d830a3c80" name="a31f6ba9ed7f80198dd444d6d830a3c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f6ba9ed7f80198dd444d6d830a3c80">&#9670;&#160;</a></span>upper_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">iterator</a> <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the end of a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to last element matching given key.</dd></dl>
<p>This function only makes sense with multimaps. </p>

</div>
</div>
<a id="afd9ba5f5b31a79317b1c5ec547b9ec6c" name="afd9ba5f5b31a79317b1c5ec547b9ec6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9ba5f5b31a79317b1c5ec547b9ec6c">&#9670;&#160;</a></span>upper_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Key , class _Tp , class _Compare  = less&lt;_Key&gt;, class _Alloc  = allocator&lt;pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstd_1_1__Rb__tree__iterator.html">const_iterator</a> <a class="el" href="classstd_1_1map.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>__x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the end of a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) iterator pointing to last element matching given key.</dd></dl>
<p>This function only makes sense with multimaps. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ts2/opm53/tools/sce/ee/gcc/include/g++-v3/bits/<a class="el" href="stl__map_8h_source.html">stl_map.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
