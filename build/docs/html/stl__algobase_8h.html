<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenRadical: ts2/opm53/tools/sce/ee/gcc/include/g++-v3/bits/stl_algobase.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenRadical
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_9210f49a5fe20be6b5321aca57fbe4d2.html">ts2</a></li><li class="navelem"><a class="el" href="dir_cc2422225e961cad96549d976097f45a.html">opm53</a></li><li class="navelem"><a class="el" href="dir_28a9c6f745bbbbc1d1cdf1b1ee6a864d.html">tools</a></li><li class="navelem"><a class="el" href="dir_f8283f63c9fcde7cdc36f59b207464ec.html">sce</a></li><li class="navelem"><a class="el" href="dir_93f94442862b7e706dd69b6e52deadc1.html">ee</a></li><li class="navelem"><a class="el" href="dir_3edb1a85ada57b6bda4ac783660f1292.html">gcc</a></li><li class="navelem"><a class="el" href="dir_48f2f1cbcc0d98b9155dace9734121ed.html">include</a></li><li class="navelem"><a class="el" href="dir_cae182e9c81325f5bb08463d427bd9c2.html">g++-v3</a></li><li class="navelem"><a class="el" href="dir_0a3552291b585753d50f2b48b0c444d4.html">bits</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">stl_algobase.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;bits/c++config.h&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;climits&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;new&gt;</code><br />
<code>#include &lt;iosfwd&gt;</code><br />
<code>#include &lt;<a class="el" href="stl__pair_8h_source.html">bits/stl_pair.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="type__traits_8h_source.html">bits/type_traits.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="stl__iterator__base__types_8h_source.html">bits/stl_iterator_base_types.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="stl__iterator__base__funcs_8h_source.html">bits/stl_iterator_base_funcs.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="stl__iterator_8h_source.html">bits/stl_iterator.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="concept__check_8h_source.html">bits/concept_check.h</a>&gt;</code><br />
</div>
<p><a href="stl__algobase_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1____copy__backward__dispatch.html">std::__copy_backward_dispatch&lt; _BidirectionalIter1, _BidirectionalIter2, _BoolType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1____copy__backward__dispatch_3_01__Tp_01_5_00_01__Tp_01_5_00_01____true__type_01_4.html">std::__copy_backward_dispatch&lt; _Tp *, _Tp *, __true_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1____copy__backward__dispatch_3_01const_01__Tp_01_5_00_01__Tp_01_5_00_01____true__type_01_4.html">std::__copy_backward_dispatch&lt; const _Tp *, _Tp *, __true_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac5544411160012fbbf3f62cd7db53b34" id="r_ac5544411160012fbbf3f62cd7db53b34"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter1 , typename _ForwardIter2 &gt; </td></tr>
<tr class="memitem:ac5544411160012fbbf3f62cd7db53b34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5544411160012fbbf3f62cd7db53b34">std::iter_swap</a> (_ForwardIter1 __a, _ForwardIter2 __b)</td></tr>
<tr class="memdesc:ac5544411160012fbbf3f62cd7db53b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two iterators.  <br /></td></tr>
<tr class="separator:ac5544411160012fbbf3f62cd7db53b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b585873ebf1825dd20842245835d664" id="r_a9b585873ebf1825dd20842245835d664"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a9b585873ebf1825dd20842245835d664"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b585873ebf1825dd20842245835d664">std::swap</a> (_Tp &amp;__a, _Tp &amp;__b)</td></tr>
<tr class="memdesc:a9b585873ebf1825dd20842245835d664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two values.  <br /></td></tr>
<tr class="separator:a9b585873ebf1825dd20842245835d664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976d02d45bf6128ae0490642d5961ced" id="r_a976d02d45bf6128ae0490642d5961ced"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a976d02d45bf6128ae0490642d5961ced"><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a976d02d45bf6128ae0490642d5961ced">std::min</a> (const _Tp &amp;__a, const _Tp &amp;__b)</td></tr>
<tr class="memdesc:a976d02d45bf6128ae0490642d5961ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">This does what you think it does.  <br /></td></tr>
<tr class="separator:a976d02d45bf6128ae0490642d5961ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fe7a943a5b88c1bba1032392a04671" id="r_a47fe7a943a5b88c1bba1032392a04671"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a47fe7a943a5b88c1bba1032392a04671"><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a47fe7a943a5b88c1bba1032392a04671">std::max</a> (const _Tp &amp;__a, const _Tp &amp;__b)</td></tr>
<tr class="memdesc:a47fe7a943a5b88c1bba1032392a04671"><td class="mdescLeft">&#160;</td><td class="mdescRight">This does what you think it does.  <br /></td></tr>
<tr class="separator:a47fe7a943a5b88c1bba1032392a04671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb5fe7f1f3affda3dbb77c4fe775e30" id="r_acdb5fe7f1f3affda3dbb77c4fe775e30"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:acdb5fe7f1f3affda3dbb77c4fe775e30"><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acdb5fe7f1f3affda3dbb77c4fe775e30">std::min</a> (const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)</td></tr>
<tr class="memdesc:acdb5fe7f1f3affda3dbb77c4fe775e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This does what you think it does.  <br /></td></tr>
<tr class="separator:acdb5fe7f1f3affda3dbb77c4fe775e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa927592dda302adb422eedd6e7b040f0" id="r_aa927592dda302adb422eedd6e7b040f0"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:aa927592dda302adb422eedd6e7b040f0"><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa927592dda302adb422eedd6e7b040f0">std::max</a> (const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)</td></tr>
<tr class="memdesc:aa927592dda302adb422eedd6e7b040f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This does what you think it does.  <br /></td></tr>
<tr class="separator:aa927592dda302adb422eedd6e7b040f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7680e361e4dc7f2a0d58d368d552099" id="r_ab7680e361e4dc7f2a0d58d368d552099"><td class="memTemplParams" colspan="2"><a id="ab7680e361e4dc7f2a0d58d368d552099" name="ab7680e361e4dc7f2a0d58d368d552099"></a>
template&lt;typename _InputIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:ab7680e361e4dc7f2a0d58d368d552099"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy</b> (_InputIter __first, _InputIter __last, _OutputIter __result, <a class="el" href="structstd_1_1input__iterator__tag.html">input_iterator_tag</a>)</td></tr>
<tr class="separator:ab7680e361e4dc7f2a0d58d368d552099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f074f79193e2be372eb657f80b3d605" id="r_a5f074f79193e2be372eb657f80b3d605"><td class="memTemplParams" colspan="2"><a id="a5f074f79193e2be372eb657f80b3d605" name="a5f074f79193e2be372eb657f80b3d605"></a>
template&lt;typename _RandomAccessIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:a5f074f79193e2be372eb657f80b3d605"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy</b> (_RandomAccessIter __first, _RandomAccessIter __last, _OutputIter __result, <a class="el" href="structstd_1_1random__access__iterator__tag.html">random_access_iterator_tag</a>)</td></tr>
<tr class="separator:a5f074f79193e2be372eb657f80b3d605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1233ff964e684e8decb0fc00e165fa8a" id="r_a1233ff964e684e8decb0fc00e165fa8a"><td class="memTemplParams" colspan="2"><a id="a1233ff964e684e8decb0fc00e165fa8a" name="a1233ff964e684e8decb0fc00e165fa8a"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a1233ff964e684e8decb0fc00e165fa8a"><td class="memTemplItemLeft" align="right" valign="top">_Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_trivial</b> (const _Tp *__first, const _Tp *__last, _Tp *__result)</td></tr>
<tr class="separator:a1233ff964e684e8decb0fc00e165fa8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f36bc83ed6e9f110009c614546142b3" id="r_a2f36bc83ed6e9f110009c614546142b3"><td class="memTemplParams" colspan="2"><a id="a2f36bc83ed6e9f110009c614546142b3" name="a2f36bc83ed6e9f110009c614546142b3"></a>
template&lt;typename _InputIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:a2f36bc83ed6e9f110009c614546142b3"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_aux2</b> (_InputIter __first, _InputIter __last, _OutputIter __result, <a class="el" href="struct____false__type.html">__false_type</a>)</td></tr>
<tr class="separator:a2f36bc83ed6e9f110009c614546142b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89db4c0bd312c35eded32020b8c718d7" id="r_a89db4c0bd312c35eded32020b8c718d7"><td class="memTemplParams" colspan="2"><a id="a89db4c0bd312c35eded32020b8c718d7" name="a89db4c0bd312c35eded32020b8c718d7"></a>
template&lt;typename _InputIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:a89db4c0bd312c35eded32020b8c718d7"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_aux2</b> (_InputIter __first, _InputIter __last, _OutputIter __result, <a class="el" href="struct____true__type.html">__true_type</a>)</td></tr>
<tr class="separator:a89db4c0bd312c35eded32020b8c718d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3385f2de2fce1efc6032a0b5551bd2b0" id="r_a3385f2de2fce1efc6032a0b5551bd2b0"><td class="memTemplParams" colspan="2"><a id="a3385f2de2fce1efc6032a0b5551bd2b0" name="a3385f2de2fce1efc6032a0b5551bd2b0"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a3385f2de2fce1efc6032a0b5551bd2b0"><td class="memTemplItemLeft" align="right" valign="top">_Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_aux2</b> (_Tp *__first, _Tp *__last, _Tp *__result, <a class="el" href="struct____true__type.html">__true_type</a>)</td></tr>
<tr class="separator:a3385f2de2fce1efc6032a0b5551bd2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3771e8923025086f2acfcf3b0aadd98" id="r_ae3771e8923025086f2acfcf3b0aadd98"><td class="memTemplParams" colspan="2"><a id="ae3771e8923025086f2acfcf3b0aadd98" name="ae3771e8923025086f2acfcf3b0aadd98"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ae3771e8923025086f2acfcf3b0aadd98"><td class="memTemplItemLeft" align="right" valign="top">_Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_aux2</b> (const _Tp *__first, const _Tp *__last, _Tp *__result, <a class="el" href="struct____true__type.html">__true_type</a>)</td></tr>
<tr class="separator:ae3771e8923025086f2acfcf3b0aadd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6fb6b014168596574535fac75a4036" id="r_aed6fb6b014168596574535fac75a4036"><td class="memTemplParams" colspan="2"><a id="aed6fb6b014168596574535fac75a4036" name="aed6fb6b014168596574535fac75a4036"></a>
template&lt;typename _InputIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:aed6fb6b014168596574535fac75a4036"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_ni2</b> (_InputIter __first, _InputIter __last, _OutputIter __result, <a class="el" href="struct____true__type.html">__true_type</a>)</td></tr>
<tr class="separator:aed6fb6b014168596574535fac75a4036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6425d2703fc960d99e4dffb45631c9" id="r_acb6425d2703fc960d99e4dffb45631c9"><td class="memTemplParams" colspan="2"><a id="acb6425d2703fc960d99e4dffb45631c9" name="acb6425d2703fc960d99e4dffb45631c9"></a>
template&lt;typename _InputIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:acb6425d2703fc960d99e4dffb45631c9"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_ni2</b> (_InputIter __first, _InputIter __last, _OutputIter __result, <a class="el" href="struct____false__type.html">__false_type</a>)</td></tr>
<tr class="separator:acb6425d2703fc960d99e4dffb45631c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035ff4afb46bc5c9dbf5805cdf0e12f3" id="r_a035ff4afb46bc5c9dbf5805cdf0e12f3"><td class="memTemplParams" colspan="2"><a id="a035ff4afb46bc5c9dbf5805cdf0e12f3" name="a035ff4afb46bc5c9dbf5805cdf0e12f3"></a>
template&lt;typename _InputIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:a035ff4afb46bc5c9dbf5805cdf0e12f3"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_ni1</b> (_InputIter __first, _InputIter __last, _OutputIter __result, <a class="el" href="struct____true__type.html">__true_type</a>)</td></tr>
<tr class="separator:a035ff4afb46bc5c9dbf5805cdf0e12f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be34a61c71aa3081f9d50083af3d6a7" id="r_a2be34a61c71aa3081f9d50083af3d6a7"><td class="memTemplParams" colspan="2"><a id="a2be34a61c71aa3081f9d50083af3d6a7" name="a2be34a61c71aa3081f9d50083af3d6a7"></a>
template&lt;typename _InputIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:a2be34a61c71aa3081f9d50083af3d6a7"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_ni1</b> (_InputIter __first, _InputIter __last, _OutputIter __result, <a class="el" href="struct____false__type.html">__false_type</a>)</td></tr>
<tr class="separator:a2be34a61c71aa3081f9d50083af3d6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd6e0a5f81f1d9cb3a7150beb1211cf" id="r_a0dd6e0a5f81f1d9cb3a7150beb1211cf"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter , typename _OutputIter &gt; </td></tr>
<tr class="memitem:a0dd6e0a5f81f1d9cb3a7150beb1211cf"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0dd6e0a5f81f1d9cb3a7150beb1211cf">std::copy</a> (_InputIter __first, _InputIter __last, _OutputIter __result)</td></tr>
<tr class="memdesc:a0dd6e0a5f81f1d9cb3a7150beb1211cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the range [first,last) into result.  <br /></td></tr>
<tr class="separator:a0dd6e0a5f81f1d9cb3a7150beb1211cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae179a3f502a5a83ca4a2a2f5c2193e2b" id="r_ae179a3f502a5a83ca4a2a2f5c2193e2b"><td class="memTemplParams" colspan="2"><a id="ae179a3f502a5a83ca4a2a2f5c2193e2b" name="ae179a3f502a5a83ca4a2a2f5c2193e2b"></a>
template&lt;typename _BidirectionalIter1 , typename _BidirectionalIter2 &gt; </td></tr>
<tr class="memitem:ae179a3f502a5a83ca4a2a2f5c2193e2b"><td class="memTemplItemLeft" align="right" valign="top">_BidirectionalIter2&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_backward</b> (_BidirectionalIter1 __first, _BidirectionalIter1 __last, _BidirectionalIter2 __result, <a class="el" href="structstd_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a>)</td></tr>
<tr class="separator:ae179a3f502a5a83ca4a2a2f5c2193e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae876bd79450e32019d60806c28c0a1" id="r_a6ae876bd79450e32019d60806c28c0a1"><td class="memTemplParams" colspan="2"><a id="a6ae876bd79450e32019d60806c28c0a1" name="a6ae876bd79450e32019d60806c28c0a1"></a>
template&lt;typename _RandomAccessIter , typename _BidirectionalIter &gt; </td></tr>
<tr class="memitem:a6ae876bd79450e32019d60806c28c0a1"><td class="memTemplItemLeft" align="right" valign="top">_BidirectionalIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_backward</b> (_RandomAccessIter __first, _RandomAccessIter __last, _BidirectionalIter __result, <a class="el" href="structstd_1_1random__access__iterator__tag.html">random_access_iterator_tag</a>)</td></tr>
<tr class="separator:a6ae876bd79450e32019d60806c28c0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21234defa1fc739d2f579de827d8fcd3" id="r_a21234defa1fc739d2f579de827d8fcd3"><td class="memTemplParams" colspan="2"><a id="a21234defa1fc739d2f579de827d8fcd3" name="a21234defa1fc739d2f579de827d8fcd3"></a>
template&lt;typename _BI1 , typename _BI2 &gt; </td></tr>
<tr class="memitem:a21234defa1fc739d2f579de827d8fcd3"><td class="memTemplItemLeft" align="right" valign="top">_BI2&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_backward_aux</b> (_BI1 __first, _BI1 __last, _BI2 __result)</td></tr>
<tr class="separator:a21234defa1fc739d2f579de827d8fcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5776b8db72d532d51ee6874d06a860ea" id="r_a5776b8db72d532d51ee6874d06a860ea"><td class="memTemplParams" colspan="2"><a id="a5776b8db72d532d51ee6874d06a860ea" name="a5776b8db72d532d51ee6874d06a860ea"></a>
template&lt;typename _BI1 , typename _BI2 &gt; </td></tr>
<tr class="memitem:a5776b8db72d532d51ee6874d06a860ea"><td class="memTemplItemLeft" align="right" valign="top">_BI2&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_backward_output_normal_iterator</b> (_BI1 __first, _BI1 __last, _BI2 __result, <a class="el" href="struct____true__type.html">__true_type</a>)</td></tr>
<tr class="separator:a5776b8db72d532d51ee6874d06a860ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce7fe4eb31e474572538414c779d462" id="r_a8ce7fe4eb31e474572538414c779d462"><td class="memTemplParams" colspan="2"><a id="a8ce7fe4eb31e474572538414c779d462" name="a8ce7fe4eb31e474572538414c779d462"></a>
template&lt;typename _BI1 , typename _BI2 &gt; </td></tr>
<tr class="memitem:a8ce7fe4eb31e474572538414c779d462"><td class="memTemplItemLeft" align="right" valign="top">_BI2&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_backward_output_normal_iterator</b> (_BI1 __first, _BI1 __last, _BI2 __result, <a class="el" href="struct____false__type.html">__false_type</a>)</td></tr>
<tr class="separator:a8ce7fe4eb31e474572538414c779d462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae03a4e19d09ef6bf91b5e5e6e77c2f" id="r_afae03a4e19d09ef6bf91b5e5e6e77c2f"><td class="memTemplParams" colspan="2"><a id="afae03a4e19d09ef6bf91b5e5e6e77c2f" name="afae03a4e19d09ef6bf91b5e5e6e77c2f"></a>
template&lt;typename _BI1 , typename _BI2 &gt; </td></tr>
<tr class="memitem:afae03a4e19d09ef6bf91b5e5e6e77c2f"><td class="memTemplItemLeft" align="right" valign="top">_BI2&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_backward_input_normal_iterator</b> (_BI1 __first, _BI1 __last, _BI2 __result, <a class="el" href="struct____true__type.html">__true_type</a>)</td></tr>
<tr class="separator:afae03a4e19d09ef6bf91b5e5e6e77c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df810b43f64c64d11b27ae6ef87acbf" id="r_a1df810b43f64c64d11b27ae6ef87acbf"><td class="memTemplParams" colspan="2"><a id="a1df810b43f64c64d11b27ae6ef87acbf" name="a1df810b43f64c64d11b27ae6ef87acbf"></a>
template&lt;typename _BI1 , typename _BI2 &gt; </td></tr>
<tr class="memitem:a1df810b43f64c64d11b27ae6ef87acbf"><td class="memTemplItemLeft" align="right" valign="top">_BI2&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::__copy_backward_input_normal_iterator</b> (_BI1 __first, _BI1 __last, _BI2 __result, <a class="el" href="struct____false__type.html">__false_type</a>)</td></tr>
<tr class="separator:a1df810b43f64c64d11b27ae6ef87acbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0de0305e64a82131960e2769624a740" id="r_af0de0305e64a82131960e2769624a740"><td class="memTemplParams" colspan="2">template&lt;typename _BI1 , typename _BI2 &gt; </td></tr>
<tr class="memitem:af0de0305e64a82131960e2769624a740"><td class="memTemplItemLeft" align="right" valign="top">_BI2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0de0305e64a82131960e2769624a740">std::copy_backward</a> (_BI1 __first, _BI1 __last, _BI2 __result)</td></tr>
<tr class="memdesc:af0de0305e64a82131960e2769624a740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the range [first,last) into result.  <br /></td></tr>
<tr class="separator:af0de0305e64a82131960e2769624a740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceebe484d10015f21c7baa8c9272c8a" id="r_a2ceebe484d10015f21c7baa8c9272c8a"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIter , typename _Tp &gt; </td></tr>
<tr class="memitem:a2ceebe484d10015f21c7baa8c9272c8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ceebe484d10015f21c7baa8c9272c8a">std::fill</a> (_ForwardIter __first, _ForwardIter __last, const _Tp &amp;__value)</td></tr>
<tr class="memdesc:a2ceebe484d10015f21c7baa8c9272c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the range [first,last) with copies of value.  <br /></td></tr>
<tr class="separator:a2ceebe484d10015f21c7baa8c9272c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd74532620b525a7b7f15e426484761e" id="r_abd74532620b525a7b7f15e426484761e"><td class="memTemplParams" colspan="2">template&lt;typename _OutputIter , typename _Size , typename _Tp &gt; </td></tr>
<tr class="memitem:abd74532620b525a7b7f15e426484761e"><td class="memTemplItemLeft" align="right" valign="top">_OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd74532620b525a7b7f15e426484761e">std::fill_n</a> (_OutputIter __first, _Size __n, const _Tp &amp;__value)</td></tr>
<tr class="memdesc:abd74532620b525a7b7f15e426484761e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the range [first,first+n) with copies of value.  <br /></td></tr>
<tr class="separator:abd74532620b525a7b7f15e426484761e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efe8499f516856afd8089c6f00dd69c" id="r_a8efe8499f516856afd8089c6f00dd69c"><td class="memItemLeft" align="right" valign="top"><a id="a8efe8499f516856afd8089c6f00dd69c" name="a8efe8499f516856afd8089c6f00dd69c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>std::fill</b> (unsigned char *__first, unsigned char *__last, const unsigned char &amp;__c)</td></tr>
<tr class="separator:a8efe8499f516856afd8089c6f00dd69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42829d4ea148275a29863a41027922a1" id="r_a42829d4ea148275a29863a41027922a1"><td class="memItemLeft" align="right" valign="top"><a id="a42829d4ea148275a29863a41027922a1" name="a42829d4ea148275a29863a41027922a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>std::fill</b> (signed char *__first, signed char *__last, const signed char &amp;__c)</td></tr>
<tr class="separator:a42829d4ea148275a29863a41027922a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d43a227cd1b83e57f04035ad13d6b50" id="r_a2d43a227cd1b83e57f04035ad13d6b50"><td class="memItemLeft" align="right" valign="top"><a id="a2d43a227cd1b83e57f04035ad13d6b50" name="a2d43a227cd1b83e57f04035ad13d6b50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>std::fill</b> (char *__first, char *__last, const char &amp;__c)</td></tr>
<tr class="separator:a2d43a227cd1b83e57f04035ad13d6b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bee60162eb6e9b486bdc58373067f35" id="r_a6bee60162eb6e9b486bdc58373067f35"><td class="memTemplParams" colspan="2"><a id="a6bee60162eb6e9b486bdc58373067f35" name="a6bee60162eb6e9b486bdc58373067f35"></a>
template&lt;typename _Size &gt; </td></tr>
<tr class="memitem:a6bee60162eb6e9b486bdc58373067f35"><td class="memTemplItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::fill_n</b> (unsigned char *__first, _Size __n, const unsigned char &amp;__c)</td></tr>
<tr class="separator:a6bee60162eb6e9b486bdc58373067f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211b40babe0e0efc96c7c83744e3478a" id="r_a211b40babe0e0efc96c7c83744e3478a"><td class="memTemplParams" colspan="2"><a id="a211b40babe0e0efc96c7c83744e3478a" name="a211b40babe0e0efc96c7c83744e3478a"></a>
template&lt;typename _Size &gt; </td></tr>
<tr class="memitem:a211b40babe0e0efc96c7c83744e3478a"><td class="memTemplItemLeft" align="right" valign="top">signed char *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::fill_n</b> (char *__first, _Size __n, const signed char &amp;__c)</td></tr>
<tr class="separator:a211b40babe0e0efc96c7c83744e3478a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7cb3d4ab4edd4af0059df00f086c5c" id="r_acb7cb3d4ab4edd4af0059df00f086c5c"><td class="memTemplParams" colspan="2"><a id="acb7cb3d4ab4edd4af0059df00f086c5c" name="acb7cb3d4ab4edd4af0059df00f086c5c"></a>
template&lt;typename _Size &gt; </td></tr>
<tr class="memitem:acb7cb3d4ab4edd4af0059df00f086c5c"><td class="memTemplItemLeft" align="right" valign="top">char *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::fill_n</b> (char *__first, _Size __n, const char &amp;__c)</td></tr>
<tr class="separator:acb7cb3d4ab4edd4af0059df00f086c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01385c518a4739b304f2a0df5cb4d04a" id="r_a01385c518a4739b304f2a0df5cb4d04a"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter1 , typename _InputIter2 &gt; </td></tr>
<tr class="memitem:a01385c518a4739b304f2a0df5cb4d04a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1pair.html">pair</a>&lt; _InputIter1, _InputIter2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a01385c518a4739b304f2a0df5cb4d04a">std::mismatch</a> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)</td></tr>
<tr class="memdesc:a01385c518a4739b304f2a0df5cb4d04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the places in ranges which don't match.  <br /></td></tr>
<tr class="separator:a01385c518a4739b304f2a0df5cb4d04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060cb05a9a38d993d14ae745c9c0272a" id="r_a060cb05a9a38d993d14ae745c9c0272a"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter1 , typename _InputIter2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:a060cb05a9a38d993d14ae745c9c0272a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstd_1_1pair.html">pair</a>&lt; _InputIter1, _InputIter2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a060cb05a9a38d993d14ae745c9c0272a">std::mismatch</a> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _BinaryPredicate __binary_pred)</td></tr>
<tr class="memdesc:a060cb05a9a38d993d14ae745c9c0272a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the places in ranges which don't match.  <br /></td></tr>
<tr class="separator:a060cb05a9a38d993d14ae745c9c0272a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7792d9648379106991dc4bd9c2ce02ab" id="r_a7792d9648379106991dc4bd9c2ce02ab"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter1 , typename _InputIter2 &gt; </td></tr>
<tr class="memitem:a7792d9648379106991dc4bd9c2ce02ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7792d9648379106991dc4bd9c2ce02ab">std::equal</a> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)</td></tr>
<tr class="memdesc:a7792d9648379106991dc4bd9c2ce02ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests a range for element-wise equality.  <br /></td></tr>
<tr class="separator:a7792d9648379106991dc4bd9c2ce02ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787e9783373aed01a26dd3d50e2a0c32" id="r_a787e9783373aed01a26dd3d50e2a0c32"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter1 , typename _InputIter2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:a787e9783373aed01a26dd3d50e2a0c32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a787e9783373aed01a26dd3d50e2a0c32">std::equal</a> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _BinaryPredicate __binary_pred)</td></tr>
<tr class="memdesc:a787e9783373aed01a26dd3d50e2a0c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests a range for element-wise equality.  <br /></td></tr>
<tr class="separator:a787e9783373aed01a26dd3d50e2a0c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8411817f7f819739ff2e0659a2f4f8b4" id="r_a8411817f7f819739ff2e0659a2f4f8b4"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter1 , typename _InputIter2 &gt; </td></tr>
<tr class="memitem:a8411817f7f819739ff2e0659a2f4f8b4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8411817f7f819739ff2e0659a2f4f8b4">std::lexicographical_compare</a> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2)</td></tr>
<tr class="memdesc:a8411817f7f819739ff2e0659a2f4f8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs "dictionary" comparison on ranges.  <br /></td></tr>
<tr class="separator:a8411817f7f819739ff2e0659a2f4f8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3453cb1d8febd7c819259e5990b5e8f9" id="r_a3453cb1d8febd7c819259e5990b5e8f9"><td class="memTemplParams" colspan="2">template&lt;typename _InputIter1 , typename _InputIter2 , typename _Compare &gt; </td></tr>
<tr class="memitem:a3453cb1d8febd7c819259e5990b5e8f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3453cb1d8febd7c819259e5990b5e8f9">std::lexicographical_compare</a> (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _Compare __comp)</td></tr>
<tr class="memdesc:a3453cb1d8febd7c819259e5990b5e8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs "dictionary" comparison on ranges.  <br /></td></tr>
<tr class="separator:a3453cb1d8febd7c819259e5990b5e8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f087465fcb6711576e994463564a804" id="r_a6f087465fcb6711576e994463564a804"><td class="memItemLeft" align="right" valign="top"><a id="a6f087465fcb6711576e994463564a804" name="a6f087465fcb6711576e994463564a804"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>std::lexicographical_compare</b> (const unsigned char *__first1, const unsigned char *__last1, const unsigned char *__first2, const unsigned char *__last2)</td></tr>
<tr class="separator:a6f087465fcb6711576e994463564a804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1476bc819c4a2c7bff708f3d3d7200" id="r_a9a1476bc819c4a2c7bff708f3d3d7200"><td class="memItemLeft" align="right" valign="top"><a id="a9a1476bc819c4a2c7bff708f3d3d7200" name="a9a1476bc819c4a2c7bff708f3d3d7200"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>std::lexicographical_compare</b> (const char *__first1, const char *__last1, const char *__first2, const char *__last2)</td></tr>
<tr class="separator:a9a1476bc819c4a2c7bff708f3d3d7200"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is an internal header file, included by other library headers. You should not attempt to use it directly. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a0dd6e0a5f81f1d9cb3a7150beb1211cf" name="a0dd6e0a5f81f1d9cb3a7150beb1211cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd6e0a5f81f1d9cb3a7150beb1211cf">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter , typename _OutputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::copy </td>
          <td>(</td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the range [first,last) into result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result + (first - last)</dd></dl>
<p>This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling). If the input range and the output range overlap, then the copy_backward function should be used instead. </p>

</div>
</div>
<a id="af0de0305e64a82131960e2769624a740" name="af0de0305e64a82131960e2769624a740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0de0305e64a82131960e2769624a740">&#9670;&#160;</a></span>copy_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BI1 , typename _BI2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_BI2 std::copy_backward </td>
          <td>(</td>
          <td class="paramtype">_BI1</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BI1</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BI2</td>          <td class="paramname"><span class="paramname"><em>__result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the range [first,last) into result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result - (first - last)</dd></dl>
<p>The function has the same effect as copy, but starts at the end of the range and works its way to the start, returning the start of the result. This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling). </p>

</div>
</div>
<a id="a7792d9648379106991dc4bd9c2ce02ab" name="a7792d9648379106991dc4bd9c2ce02ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7792d9648379106991dc4bd9c2ce02ab">&#9670;&#160;</a></span>equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter1 , typename _InputIter2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool std::equal </td>
          <td>(</td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter2</td>          <td class="paramname"><span class="paramname"><em>__first2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests a range for element-wise equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">first2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>This compares the elements of two ranges using <code>==</code> and returns true or false depending on whether all of the corresponding elements of the ranges are equal. </p>

</div>
</div>
<a id="a787e9783373aed01a26dd3d50e2a0c32" name="a787e9783373aed01a26dd3d50e2a0c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787e9783373aed01a26dd3d50e2a0c32">&#9670;&#160;</a></span>equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter1 , typename _InputIter2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool std::equal </td>
          <td>(</td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter2</td>          <td class="paramname"><span class="paramname"><em>__first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate</td>          <td class="paramname"><span class="paramname"><em>__binary_pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests a range for element-wise equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>A binary predicate <a class="el" href="group__s20__3__1__base.html">functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>This compares the elements of two ranges using the binary_pred parameter, and returns true or false depending on whether all of the corresponding elements of the ranges are equal. </p>

</div>
</div>
<a id="a2ceebe484d10015f21c7baa8c9272c8a" name="a2ceebe484d10015f21c7baa8c9272c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceebe484d10015f21c7baa8c9272c8a">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::fill </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter</td>          <td class="paramname"><span class="paramname"><em>__last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the range [first,last) with copies of value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">value</td><td>A reference-to-const of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function fills a range with copies of the same value. For one-byte types filling contiguous areas of memory, this becomes an inline call to <code>memset</code>. </p>

</div>
</div>
<a id="abd74532620b525a7b7f15e426484761e" name="abd74532620b525a7b7f15e426484761e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd74532620b525a7b7f15e426484761e">&#9670;&#160;</a></span>fill_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _OutputIter , typename _Size , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIter std::fill_n </td>
          <td>(</td>
          <td class="paramtype">_OutputIter</td>          <td class="paramname"><span class="paramname"><em>__first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Size</td>          <td class="paramname"><span class="paramname"><em>__n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the range [first,first+n) with copies of value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">n</td><td>The count of copies to perform. </td></tr>
    <tr><td class="paramname">value</td><td>A reference-to-const of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator at first+n.</dd></dl>
<p>This function fills a range with copies of the same value. For one-byte types filling contiguous areas of memory, this becomes an inline call to <code>memset</code>. </p>

</div>
</div>
<a id="ac5544411160012fbbf3f62cd7db53b34" name="ac5544411160012fbbf3f62cd7db53b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5544411160012fbbf3f62cd7db53b34">&#9670;&#160;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIter1 , typename _ForwardIter2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::iter_swap </td>
          <td>(</td>
          <td class="paramtype">_ForwardIter1</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIter2</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of two iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An iterator. </td></tr>
    <tr><td class="paramname">b</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function swaps the values pointed to by two iterators, not the iterators themselves. </p>

</div>
</div>
<a id="a8411817f7f819739ff2e0659a2f4f8b4" name="a8411817f7f819739ff2e0659a2f4f8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8411817f7f819739ff2e0659a2f4f8b4">&#9670;&#160;</a></span>lexicographical_compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter1 , typename _InputIter2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter2</td>          <td class="paramname"><span class="paramname"><em>__first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter2</td>          <td class="paramname"><span class="paramname"><em>__last2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs "dictionary" comparison on ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>"Returns true if the sequence of elements defined by the range
[first1,last1) is lexicographically less than the sequence of elements
defined by the range [first2,last2).  Returns false otherwise." (Quoted from [25.3.8]/1.) If the iterators are all character pointers, then this is an inline call to <code>memcmp</code>. </p>

</div>
</div>
<a id="a3453cb1d8febd7c819259e5990b5e8f9" name="a3453cb1d8febd7c819259e5990b5e8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3453cb1d8febd7c819259e5990b5e8f9">&#9670;&#160;</a></span>lexicographical_compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter1 , typename _InputIter2 , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter2</td>          <td class="paramname"><span class="paramname"><em>__first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter2</td>          <td class="paramname"><span class="paramname"><em>__last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs "dictionary" comparison on ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">comp</td><td>A <a class="el" href="group__s20__3__3__comparisons.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>The same as the four-parameter <code>lexigraphical_compare</code>, but uses the comp parameter instead of <code>&lt;</code>. </p>

</div>
</div>
<a id="a47fe7a943a5b88c1bba1032392a04671" name="a47fe7a943a5b88c1bba1032392a04671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fe7a943a5b88c1bba1032392a04671">&#9670;&#160;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; std::max </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greater of the parameters.</dd></dl>
<p>This is the simple classic generic implementation. It will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

</div>
</div>
<a id="aa927592dda302adb422eedd6e7b040f0" name="aa927592dda302adb422eedd6e7b040f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa927592dda302adb422eedd6e7b040f0">&#9670;&#160;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; std::max </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">comp</td><td>A <a class="el" href="group__s20__3__3__comparisons.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greater of the parameters.</dd></dl>
<p>This will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

</div>
</div>
<a id="a976d02d45bf6128ae0490642d5961ced" name="a976d02d45bf6128ae0490642d5961ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976d02d45bf6128ae0490642d5961ced">&#9670;&#160;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; std::min </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lesser of the parameters.</dd></dl>
<p>This is the simple classic generic implementation. It will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

</div>
</div>
<a id="acdb5fe7f1f3affda3dbb77c4fe775e30" name="acdb5fe7f1f3affda3dbb77c4fe775e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb5fe7f1f3affda3dbb77c4fe775e30">&#9670;&#160;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; std::min </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare</td>          <td class="paramname"><span class="paramname"><em>__comp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">comp</td><td>A <a class="el" href="group__s20__3__3__comparisons.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lesser of the parameters.</dd></dl>
<p>This will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

</div>
</div>
<a id="a01385c518a4739b304f2a0df5cb4d04a" name="a01385c518a4739b304f2a0df5cb4d04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01385c518a4739b304f2a0df5cb4d04a">&#9670;&#160;</a></span>mismatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter1 , typename _InputIter2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; _InputIter1, _InputIter2 &gt; std::mismatch </td>
          <td>(</td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter2</td>          <td class="paramname"><span class="paramname"><em>__first2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the places in ranges which don't match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">first2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first mismatch.</dd></dl>
<p>This compares the elements of two ranges using <code>==</code> and returns a pair of iterators. The first iterator points into the first range, the second iterator points into the second range, and the elements pointed to by the iterators are not equal. </p>

</div>
</div>
<a id="a060cb05a9a38d993d14ae745c9c0272a" name="a060cb05a9a38d993d14ae745c9c0272a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060cb05a9a38d993d14ae745c9c0272a">&#9670;&#160;</a></span>mismatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIter1 , typename _InputIter2 , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; _InputIter1, _InputIter2 &gt; std::mismatch </td>
          <td>(</td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter1</td>          <td class="paramname"><span class="paramname"><em>__last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIter2</td>          <td class="paramname"><span class="paramname"><em>__first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate</td>          <td class="paramname"><span class="paramname"><em>__binary_pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the places in ranges which don't match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>A binary predicate <a class="el" href="group__s20__3__1__base.html">functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first mismatch.</dd></dl>
<p>This compares the elements of two ranges using the binary_pred parameter, and returns a pair of iterators. The first iterator points into the first range, the second iterator points into the second range, and the elements pointed to by the iterators are not equal. </p>

</div>
</div>
<a id="a9b585873ebf1825dd20842245835d664" name="a9b585873ebf1825dd20842245835d664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b585873ebf1825dd20842245835d664">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::swap </td>
          <td>(</td>
          <td class="paramtype">_Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Tp &amp;</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This is the simple classic generic implementation. It will work on any type which has a copy constructor and an assignment operator. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
